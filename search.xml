<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello myblog</title>
    <url>/2023/04/14/Hello-myblog/</url>
    <content><![CDATA[<h1 id="Hello-myblog"><a href="#Hello-myblog" class="headerlink" title="Hello myblog"></a>Hello myblog</h1><h2 id="这是我的发布-水-的第一篇博客，简单纪念一下！！！"><a href="#这是我的发布-水-的第一篇博客，简单纪念一下！！！" class="headerlink" title="这是我的发布(水)的第一篇博客，简单纪念一下！！！"></a>这是我的发布(水)的第一篇博客，简单纪念一下！！！</h2><h2 id="大概花了五天时间搭建并美化了博客，前三天搭建，后两天美化"><a href="#大概花了五天时间搭建并美化了博客，前三天搭建，后两天美化" class="headerlink" title="大概花了五天时间搭建并美化了博客，前三天搭建，后两天美化"></a>大概花了五天时间搭建并美化了博客，前三天搭建，后两天美化</h2><h2 id="下面简单介绍一下-GitHub-Hexo-搭建个人博客的准备吧"><a href="#下面简单介绍一下-GitHub-Hexo-搭建个人博客的准备吧" class="headerlink" title="下面简单介绍一下 GitHub + Hexo 搭建个人博客的准备吧"></a>下面简单介绍一下 GitHub + Hexo 搭建个人博客的准备吧</h2><h3 id="搭建准备"><a href="#搭建准备" class="headerlink" title="搭建准备"></a>搭建准备</h3><ul>
<li>注册Github账号，并搭建仓库（文件托管平台，我们博客目录文件存放的地方）<br><a href="https://github.com/">github地址，点击即可传送</a></li>
<li>下载安装并配置Node.js<br><a href="https://nodejs.org/en/download">Node.js下载地址</a> </li>
<li>下载Git（访问和修改博客的接口）<br><a href="https://git-scm.com/download/win">Git下载地址</a></li>
</ul>
]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>Java_StringBuffer类</title>
    <url>/2023/06/04/Java-StringBuffer%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Java常用实用类学习——StringBuffer类"><a href="#Java常用实用类学习——StringBuffer类" class="headerlink" title="Java常用实用类学习——StringBuffer类"></a>Java常用实用类学习——StringBuffer类</h1><p>StringBuffer类与String类不同，StringBuffer类的对象的的实体的内存空间可以自动改变大小，便于存放一个可变的字符序列。尽管String类是Java.lang包中的final类，但该类提供了修改字符序列的方法。</p>
<h2 id="StringBuffer类的对象"><a href="#StringBuffer类的对象" class="headerlink" title="StringBuffer类的对象"></a>StringBuffer类的对象</h2><p>StringBuffer类有3个构造方法</p>
<h3 id="StringBuffer-；"><a href="#StringBuffer-；" class="headerlink" title="StringBuffer()；"></a>StringBuffer()；</h3><p>使用无参的构造方法创建一个StringBuffer对象，那么分配给该对象的实体初始容量可以容纳16个字符，实体容量大于16时，容量自动增加。StringBuffer对象可以通过***length()<em><strong>方法获取实体中存放的字符序列的长度，通过</strong></em>capacity()***方法获取当前实体的实际容量。</p>
<h3 id="StringBuffer-int-size"><a href="#StringBuffer-int-size" class="headerlink" title="StringBuffer(int size);"></a>StringBuffer(int size);</h3><p>使用本构造方法创建一个StringBuffer对象，那么可以分配给该对象的实体初始容量为参数size指定的字符个数，实体容量大于size时，容量自动增加。</p>
<h3 id="StringBuffer-String-s"><a href="#StringBuffer-String-s" class="headerlink" title="StringBuffer(String s);"></a>StringBuffer(String s);</h3><p>使用本构造方法创建一个StringBuffer对象，那么可以分配给该对象的实体初始容量为参数s的字符序列的长度再加16。</p>
<h2 id="StringBuffer类的常用方法"><a href="#StringBuffer类的常用方法" class="headerlink" title="StringBuffer类的常用方法"></a>StringBuffer类的常用方法</h2><h3 id="append"><a href="#append" class="headerlink" title="append();"></a>append();</h3><ul>
<li>StringBuffer append(String s)：</li>
</ul>
<p>将字符串s的字符序列追加到当前StringBuffer对象的字符序列中，并返回当前对象的引用</p>
<ul>
<li>StringBuffer append(int n)：</li>
</ul>
<p>将int型数组n转换为String对象，再将其加入当前StringBuffer对象的字符序列中，并返回当前对象的引用</p>
<ul>
<li>StringBuffer append(Object o)：</li>
</ul>
<p>将一个对象o的字符序列表示追加到当前StringBuffer对象的字符序列中，并返回当前对象的引用</p>
<p>类似的方法还有**StringBuffer append(long n)<strong>、</strong>StringBuffer append(boolean n)<strong>、</strong>StringBuffer append(float n)<strong>、</strong>StringBuffer append(double n)<strong>和</strong>StringBuffer append(char n)**。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我喜欢&quot;</span>);</span><br><span class="line">s.append(<span class="string">&quot;篮球&quot;</span>);</span><br><span class="line"><span class="comment">//当前s的实体为：我喜欢篮球</span></span><br></pre></td></tr></table></figure>



<h3 id="public-char-charAt-int-n"><a href="#public-char-charAt-int-n" class="headerlink" title="public char charAt(int n);"></a>public char charAt(int n);</h3><p>得到对象的字符序列位置n上的字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我喜欢篮球&quot;</span>);</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//c为：欢</span></span><br></pre></td></tr></table></figure>



<h3 id="public-void-setCharAt-int-n-char-ch"><a href="#public-void-setCharAt-int-n-char-ch" class="headerlink" title="public void setCharAt(int n,char ch);"></a>public void setCharAt(int n,char ch);</h3><p>将对象的字符序列位置n上的字符用参数ch代替</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我喜欢篮球&quot;</span>);</span><br><span class="line">s.charAt(<span class="number">3</span>，<span class="string">&#x27;足&#x27;</span>);</span><br><span class="line"><span class="comment">//此时s的实体为：我喜欢足球</span></span><br></pre></td></tr></table></figure>



<h3 id="StringBuffer-insert-int-index-String-str"><a href="#StringBuffer-insert-int-index-String-str" class="headerlink" title="StringBuffer insert(int index,String str);"></a>StringBuffer insert(int index,String str);</h3><p>将str插入到index位置，并返回当前对象的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我喜欢篮球&quot;</span>);</span><br><span class="line">s.charAt(<span class="number">3</span>,<span class="string">&quot;唱、跳、rap和&quot;</span>);</span><br><span class="line"><span class="comment">//此时s为：我喜欢唱、跳、rap和篮球</span></span><br></pre></td></tr></table></figure>



<h3 id="public-StringBuffer-reverse"><a href="#public-StringBuffer-reverse" class="headerlink" title="public StringBuffer reverse();"></a>public StringBuffer reverse();</h3><p>将当前对象实体中的字符序列翻转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我喜欢篮球&quot;</span>);</span><br><span class="line">s.reverse();</span><br><span class="line"><span class="comment">//此时s为：球蓝欢喜我</span></span><br></pre></td></tr></table></figure>



<h3 id="StringBuffer-delete-int-startIndex-int-endIndex"><a href="#StringBuffer-delete-int-startIndex-int-endIndex" class="headerlink" title="StringBuffer delete(int startIndex,int endIndex);"></a>StringBuffer delete(int startIndex,int endIndex);</h3><p>将当前对象的字符序列中删除一个子字符序列，删除的子字符序列从下标<em><strong>startIndex</strong></em>到<em><strong>endIndex-1</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我喜欢篮球&quot;</span>);</span><br><span class="line">s.delete(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//此时s为：我喜欢</span></span><br></pre></td></tr></table></figure>



<h3 id="StringBuffer-replace-int-startIndex-int-endIndex-String-str"><a href="#StringBuffer-replace-int-startIndex-int-endIndex-String-str" class="headerlink" title="StringBuffer replace(int startIndex,int endIndex,String str);"></a>StringBuffer replace(int startIndex,int endIndex,String str);</h3><p>将当前对象的字符序列从下标<em><strong>startIndex</strong></em>到<em><strong>endIndex-1</strong></em>替换为参数str</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我喜欢篮球&quot;</span>);</span><br><span class="line">s.replace(<span class="number">3</span>,<span class="number">5</span>,<span class="string">&quot;足球&quot;</span>);</span><br><span class="line"><span class="comment">//此时s为：我喜欢足球</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java_String类</title>
    <url>/2023/06/02/Java-String%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Java常用实用类学习——String类"><a href="#Java常用实用类学习——String类" class="headerlink" title="Java常用实用类学习——String类"></a>Java常用实用类学习——String类</h1><p>String类是java中用于处理字符序列的类。String类在java.lang包中，java把String类定义为final类，用户不能拓展String类，即String类不能有子类。</p>
<h2 id="构造String对象"><a href="#构造String对象" class="headerlink" title="构造String对象"></a>构造String对象</h2><p>String对象习惯地被翻译为字符串对象。</p>
<h3 id="常量对象"><a href="#常量对象" class="headerlink" title="常量对象"></a>常量对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hi</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Java把用户程序的String常量都放在常量池，所以hi和hello的引用和实体是相同的</p>
<h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用String类声明对象并创建对象，凡是new运算符构造构造出的对象都不放在常量池中，所以，尽管s和t的实体是相同（s.equals(t)的值是true），但二者引用不同（ s&#x3D;&#x3D;t 结果是false）。</p>
<p>String类还有两个常见方法</p>
<ol>
<li>String(char a[]);</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>String(char a[],int startIndex,int count);</li>
</ol>
<p>提取字符数组a中的一部分字符创建对象，startIndex和count是截取的起始位置和截取长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[] = &#123;<span class="string">&#x27;你&#x27;</span>,<span class="string">&#x27;好&#x27;</span>,<span class="string">&#x27;呀&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(a,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;好呀&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p>对象的变量中存储的值不能再发生变化，原因是String是final类，String类也没有给其对象提供修改实体的方法。</p>
<h2 id="String对象的并置"><a href="#String对象的并置" class="headerlink" title="String对象的并置"></a>String对象的并置</h2><p>String对象可以使用”+“进行并置运算，即首尾相接得到一个新的String对象。</p>
<ul>
<li>参与并置运算的String对象中有一个是变量，那么就会得到新的引用和实体</li>
<li>参与并置运算的对象都是常量，那么得到的仍然是常量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">testOne</span> <span class="operator">=</span> <span class="string">&quot;你&quot;</span> + <span class="string">&quot;好&quot;</span>;</span><br><span class="line"><span class="comment">//hello、testOne的引用相同，即hello == testOne的结果为true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">you</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;你&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">hi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;好&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">textTwo</span> <span class="operator">=</span> you + hi;</span><br><span class="line"><span class="comment">//textTwo、testOne的引用不同，即textTwo == testOne的结果为false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h2><h3 id="public-int-length"><a href="#public-int-length" class="headerlink" title="public int length();"></a>public int length();</h3><p>String类中的length()方法来获取一个String对象的字符序列的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;戈仑石人&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();      <span class="comment">//n的值为4</span></span><br></pre></td></tr></table></figure>



<h3 id="public-boolean-equals-String-s"><a href="#public-boolean-equals-String-s" class="headerlink" title="public boolean equals(String s);"></a>public boolean equals(String s);</h3><p>调用该方法比较当前String对象的字符序列是否与参数s指定的String对象的字符序列相同（比较实体是否相同）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;加农炮&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;加农炮&quot;</span>);</span><br><span class="line">s1.equals(s2);                    		<span class="comment">//true</span></span><br><span class="line">s1 == s2;						 	 	<span class="comment">//false</span></span><br><span class="line"><span class="comment">//注意“==”和equals(String s)用法的区别。前者比较引用是否相同，后者判断实体是否相同</span></span><br></pre></td></tr></table></figure>





<h3 id="public-boolean-startsWith-String-s"><a href="#public-boolean-startsWith-String-s" class="headerlink" title="public boolean startsWith(String s);"></a>public boolean startsWith(String s);</h3><p>判断当前对象的字符序列前缀是否为参数指定的s</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;每张卡牌生来平等，皇家巨人也不例外&quot;</span>;</span><br><span class="line">s.startsWith(<span class="string">&quot;每张&quot;</span>);                                 <span class="comment">//true</span></span><br><span class="line">s.startsWith(<span class="string">&quot;卡牌&quot;</span>);								 <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h3 id="public-boolean-endWith-String-s"><a href="#public-boolean-endWith-String-s" class="headerlink" title="public boolean endWith(String s);"></a>public boolean endWith(String s);</h3><p>判断当前对象的字符序列后缀是否为参数指定的s</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;每张卡牌生来平等，皇家巨人也不例外&quot;</span>;</span><br><span class="line">s.endsWith(<span class="string">&quot;例外&quot;</span>);                                 <span class="comment">//true</span></span><br><span class="line">s.endsWith(<span class="string">&quot;卡牌&quot;</span>);								 <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h3 id="public-int-compareTo-String-s"><a href="#public-int-compareTo-String-s" class="headerlink" title="public int compareTo(String s);"></a>public int compareTo(String s);</h3><p>对象调用该方法按字典序与参数s的字符序列比较大小。相同返回0，大于s返回正值，小于s返回负值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">s.compareTo(<span class="string">&quot;boy&quot;</span>);      <span class="comment">//负值</span></span><br><span class="line">s.compareTo(<span class="string">&quot;aba&quot;</span>);      <span class="comment">//正值</span></span><br></pre></td></tr></table></figure>



<h3 id="public-boolean-contains-String-s"><a href="#public-boolean-contains-String-s" class="headerlink" title="public boolean contains(String s);"></a>public boolean contains(String s);</h3><p>判断当前对象中是否包含参数s中的字符序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;瓦基丽武神&quot;</span>; </span><br><span class="line">s.contains(<span class="string">&quot;武神&quot;</span>);       <span class="comment">//true</span></span><br><span class="line">s.contains(<span class="string">&quot;丽丽&quot;</span>);		<span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h3 id="public-int-indexOf-String-s"><a href="#public-int-indexOf-String-s" class="headerlink" title="public int indexOf(String s);"></a>public int indexOf(String s);</h3><p>从0位置开始索引首次出现参数s出现位置，并返回该位置，如果没有检索到则返回-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;上海自来水来自海上&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.indexOf(<span class="string">&quot;海&quot;</span>);          <span class="comment">//n等于1</span></span><br></pre></td></tr></table></figure>



<h3 id="public-int-lastIndexOf-String-s"><a href="#public-int-lastIndexOf-String-s" class="headerlink" title="public int lastIndexOf(String s);"></a>public int lastIndexOf(String s);</h3><p>从0位置开始索引最后一次出现参数s出现位置，并返回该位置，如果没有检索到则返回-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;上海自来水来自海上&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.lastIndexOf(<span class="string">&quot;海&quot;</span>);       <span class="comment">//n等于7</span></span><br></pre></td></tr></table></figure>



<h3 id="public-String-substring-int-startpoint"><a href="#public-String-substring-int-startpoint" class="headerlink" title="public String substring(int startpoint);"></a>public String substring(int startpoint);</h3><p>复制从位置startpoint到最后位置上的字符到新的字符序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;我喜欢唱、跳、rap、篮球&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s7.substring(<span class="number">3</span>);           <span class="comment">//s2的字符序列是：唱、跳、rap、篮球</span></span><br></pre></td></tr></table></figure>

<p>PS：substring(int start，int end)为复制从start位置至end-1位置</p>
<h3 id="public-String-trim"><a href="#public-String-trim" class="headerlink" title="public String trim();"></a>public String trim();</h3><p>调用该方法将得到一个新的对象，该对象是当前对象的字符序列<em><strong>去掉前后空格</strong></em>的字符序列</p>
<h2 id="String对象与基本数据的相互转换"><a href="#String对象与基本数据的相互转换" class="headerlink" title="String对象与基本数据的相互转换"></a>String对象与基本数据的相互转换</h2><h3 id="将String转换为基本型"><a href="#将String转换为基本型" class="headerlink" title="将String转换为基本型"></a>将String转换为基本型</h3><p>使用Java.lang包中的<em><strong>Integer</strong></em>类调用其类方法***public static int parseInt(String s)***可以将由”数字“字符组成的字符序列转化为int型数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">x = Integer.parseInt(s);</span><br></pre></td></tr></table></figure>

<p>类似，使用java.lang包中的Byte、Short、Long、Float、Double类调用相应的类方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Floatpublic <span class="keyword">static</span> <span class="type">byte</span> <span class="title function_">parseByte</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">parseShort</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">parseLong</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">parseFloat</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">parseDouble</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException    </span><br></pre></td></tr></table></figure>



<h3 id="将基本型转换为String对象"><a href="#将基本型转换为String对象" class="headerlink" title="将基本型转换为String对象"></a>将基本型转换为String对象</h3><p>可以使用以下String类的类方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">byte</span> n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">float</span> n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">double</span> n)</span>    </span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.valueOf(<span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用到上面介绍的并置运算，即使用一个空字符串与基本型数据进行并置运算</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + <span class="number">1234</span>;</span><br></pre></td></tr></table></figure>



<h3 id="基本型数据的进制表示"><a href="#基本型数据的进制表示" class="headerlink" title="基本型数据的进制表示"></a>基本型数据的进制表示</h3><p>可以把整形数据（例如int、long型数据的二进制、八进制、或十六进制）转换成String对象，即让String对象封装的字符序列是int或long型数据的二进制、八进制或十六进制。</p>
<p>Integer和long类的下列类方法返回整数的进制的String对象表示（负数返回补码），即返回的String对象封装的字符序列是<em><strong>参数的相应进制</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toBinaryString</span><span class="params">(<span class="type">int</span> i)</span>       <span class="comment">//二进制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toOctalString</span><span class="params">(<span class="type">int</span> i)</span>		 <span class="comment">//八进制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toHexString</span><span class="params">(<span class="type">int</span> i)</span>			 <span class="comment">//十六进制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toBinaryString</span><span class="params">(<span class="type">long</span> i)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toOctalString</span><span class="params">(<span class="type">long</span> i)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">tohexString</span><span class="params">(<span class="type">long</span> i)</span></span><br></pre></td></tr></table></figure>



<h3 id="关于main-方法的参数化"><a href="#关于main-方法的参数化" class="headerlink" title="关于main()方法的参数化"></a>关于main()方法的参数化</h3><p>使用解释器java.exe执行程序来执行主类时，从键盘输入若干字符序列 ，用空格分开，它们分别对应args[0]、args[1]、args[2]……</p>
<h2 id="对象的String表示"><a href="#对象的String表示" class="headerlink" title="对象的String表示"></a>对象的String表示</h2><p>所有的类都默认是java.lang包中Object类的子类或间接子类。Object类有一个public String toString()方法，一个对象调用该方法返回String对象的字符序列的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建对象的类的名字@对象的引用</span><br><span class="line"></span><br><span class="line">System.out.println(object);</span><br><span class="line">//等价于</span><br><span class="line">System.out,println(object.toString)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java_IO流(一)</title>
    <url>/2023/11/14/Java_IO%E6%B5%81(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="File、IO流概述"><a href="#File、IO流概述" class="headerlink" title="File、IO流概述"></a>File、IO流概述</h1><ol>
<li><p>File：代表文件</p>
<ul>
<li><p>File是<code>java.io</code>包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）。</p>
</li>
<li><p>File类可以实现获取文件信息（大小、文件名、修改时间）、判断文件类型、创建文件&#x2F;文件夹、删除文件&#x2F;文件夹等操作</p>
</li>
<li><p>注意：File类只能对文件本身进行操作，不能读写文件里面存储的数据</p>
</li>
</ul>
</li>
<li><p>IO流：读取文件</p>
<ul>
<li>用于读写数据的（可以读写文件，或者网络中的数据…）</li>
</ul>
</li>
</ol>
<h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><ol>
<li><p>File类对象构造方法：</p>
<table>
<thead>
<tr>
<th align="center">构造方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public File(String pathname)</code></td>
<td align="center">根据文件路径创建文件对象</td>
</tr>
<tr>
<td align="center"><code>public File(String parent, String child)</code></td>
<td align="center">根据父路径和子路径名字创建文件对象</td>
</tr>
<tr>
<td align="center"><code>public File(File parent, String child)</code></td>
<td align="center">根据父路径对应文件对象和子路径名字创建文件对象</td>
</tr>
</tbody></table>
</li>
<li><p>注意：</p>
<ul>
<li>File对象既可以代表文件，也可以代表文件夹。</li>
<li>File封装的对象仅仅是一个路径名，这个路径可以是存在的，也允许是不存在的。</li>
</ul>
</li>
<li><p>绝对路径、相对路径</p>
<ul>
<li>绝对路径：从盘符开始。</li>
<li>相对路径：不带盘符，默认直接到当前工程下的目录寻求文件。</li>
</ul>
</li>
</ol>
<h2 id="常用方法1：判断文件类型、获取文件信息"><a href="#常用方法1：判断文件类型、获取文件信息" class="headerlink" title="常用方法1：判断文件类型、获取文件信息"></a>常用方法1：判断文件类型、获取文件信息</h2><table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public boolean exists()</code></td>
<td align="center">判断当前文件对象，对应的文件路径是否存在，存在返回true</td>
</tr>
<tr>
<td align="center"><code>public boolean isFile()</code></td>
<td align="center">判断当前文件对象指代的是否为文件，是则返回true，反之</td>
</tr>
<tr>
<td align="center"><code>public boolean isDirectory()</code></td>
<td align="center">判断当前文件对象指代的是否为文件夹，是则返回true，反之</td>
</tr>
<tr>
<td align="center"><code>public String getName()</code></td>
<td align="center">获取文件的名称（包含后缀）</td>
</tr>
<tr>
<td align="center"><code>public long length()</code></td>
<td align="center">获取文件的大小，返回字节个数</td>
</tr>
<tr>
<td align="center"><code>public long lastModified()</code></td>
<td align="center">获取文件的最后修改时间</td>
</tr>
<tr>
<td align="center"><code>public String getPath()</code></td>
<td align="center">获取创建文件对象时，使用的路径</td>
</tr>
<tr>
<td align="center"><code>public String getAbsolutePath()</code></td>
<td align="center">获取绝对路径</td>
</tr>
</tbody></table>
<h2 id="常用方法2：创建文件、删除文件"><a href="#常用方法2：创建文件、删除文件" class="headerlink" title="常用方法2：创建文件、删除文件"></a>常用方法2：创建文件、删除文件</h2><ol>
<li><p>File类创建文件的功能</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public boolean createNewFile() </code></td>
<td align="center">创建一个新的空文件</td>
</tr>
<tr>
<td align="center"><code>public boolean mkdir()</code></td>
<td align="center">只能创建一级文件夹</td>
</tr>
<tr>
<td align="center"><code>public boolean mkdirs()</code></td>
<td align="center">可以创建多级文件夹</td>
</tr>
</tbody></table>
</li>
<li><p>File类删除文件的功能</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public boolean delete()</code></td>
<td align="center">删除文件、空文件夹</td>
</tr>
</tbody></table>
<p>注意：<code>delete</code>方法默认只能删除文件和空文件夹，删除后的文件不会进入回收站。</p>
</li>
</ol>
<h2 id="常用方法3：遍历文件夹"><a href="#常用方法3：遍历文件夹" class="headerlink" title="常用方法3：遍历文件夹"></a>常用方法3：遍历文件夹</h2><ol>
<li><p>File类提供遍历文件夹的功能</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public String[] list()</code></td>
<td align="center">获取当前目录下所有的“一级文件名称”到一个字符串数组中去返回</td>
</tr>
<tr>
<td align="center"><code>public File[] listFiles()</code></td>
<td align="center">获取当前目录下所有的“一级文件对象”到一个文件对象数组中去返回（重点）</td>
</tr>
</tbody></table>
</li>
<li><p>使用<code>listFlies</code>方法时的注意事项：</p>
<ul>
<li>当主调时文件，或者路径不存在时，返回null</li>
<li>当主调是空文件夹时，返回一个长度为0的数组</li>
<li>当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹的路径放在File数组中返回</li>
<li>当主调是一个文件夹，且里面有隐藏文件时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件</li>
<li>当主调是一个文件夹，但是没有权限访问该文件夹时，返回null</li>
</ul>
</li>
</ol>
<h1 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h1><h2 id="方法递归"><a href="#方法递归" class="headerlink" title="方法递归"></a>方法递归</h2><ol>
<li><p>什么是方法递归？</p>
<ul>
<li>递归是一种算法，在程序设计语言中广泛应用</li>
<li>从形式上说：方法调用自身的形式称为方法递归（recursion）</li>
</ul>
</li>
<li><p>递归的形式</p>
<ul>
<li>直接递归：方法自己调用自己</li>
<li>间接递归：方法调用其他方法，其他方法又回调方法自己</li>
</ul>
</li>
<li><p>使用方法递归时需要注意的问题：</p>
<ul>
<li>递归如果没有控制好终止，会出现递归死循环，导致栈内存溢出错误</li>
</ul>
</li>
<li><p>递归算法三要素：</p>
<ul>
<li>递归公式</li>
<li>递归的终结点</li>
<li>递归的方向必须要走向终止点</li>
</ul>
</li>
<li><p>其他应用：文件搜索</p>
<ul>
<li><p>分析：</p>
<ol>
<li>先找出该当前文件夹下的所有一级目录</li>
<li>遍历全部一级对象，判断是否是文件</li>
<li>如果是文件，判断是否是自己想要的</li>
<li>如果是文件夹，需要继续进入到该文件夹，重复上述过程</li>
</ol>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span>);</span><br><span class="line">        searchFile(f, <span class="string">&quot;QQ&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir 目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 要搜索的文件名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(File dir, String fileName)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.拦截非法情况</span></span><br><span class="line">        <span class="keyword">if</span> (!dir.exists() || dir.isFile() ||dir == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.获取该当前目录下所有一级目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.判断当前目录下是否存在文件对象</span></span><br><span class="line">        <span class="keyword">if</span> (files != <span class="literal">null</span> &amp;&amp; files.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4.遍历全部一级文件对象</span></span><br><span class="line">            <span class="keyword">for</span> (File f : files)&#123;</span><br><span class="line">                <span class="comment">// 5.判断是否为文件</span></span><br><span class="line">                <span class="keyword">if</span> (f.isFile())&#123;</span><br><span class="line">                    <span class="keyword">if</span> (f.getName().contains(fileName))&#123;</span><br><span class="line">                        System.out.println(f.getAbsoluteFile());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    searchFile(f, fileName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><h3 id="常见字符集介绍"><a href="#常见字符集介绍" class="headerlink" title="常见字符集介绍"></a>常见字符集介绍</h3><ol>
<li><p>标准ASCII字符集</p>
<ul>
<li>ASCII(American Standard Code for Information Interchange)：美国信息交换标准代码，包括英文、符号等。</li>
<li>标准ASCIII使用1个字节存储一个字符，首尾是0总共可以表示128个字符。</li>
</ul>
</li>
<li><p>GBK（汉字内码扩展规范，国标）</p>
<ul>
<li>汉字编码字符集，包含了2万多个汉字等字符，GBK中一个中文字符编码成两个字节的形式存储。</li>
<li>注意：GBK兼容了ASCII字符集</li>
<li>GBK规定：汉字的第一个字节的第一位必须是1</li>
</ul>
</li>
<li><p>Unicode字符集(统一码，也叫万国码)</p>
<ul>
<li>Unicode是国际组织制定的，可以容纳世界上所有文字、符号的字符集</li>
<li><code>UTF-32</code>：四个字节表示一个字符，但由于占存储空间大、通信效率变低等原因，并没有被完全采纳</li>
</ul>
</li>
<li><p>UTF-8</p>
<ul>
<li><p><code>UTF-8</code>是Unicode字符集的一种编码方案，采取可变长编码方案，共分四个长度区：1个字节，2个字节，3个字节，4个字节</p>
</li>
<li><p>英文字符、数字等只占1个字节（兼容标准ASCII编码），汉字字符占用3个字节</p>
</li>
<li><p>UTF-8编码方式：</p>
<table>
<thead>
<tr>
<th>UTF-8编码方式（二进制）</th>
</tr>
</thead>
<tbody><tr>
<td><code>0xxxxxxx</code>：   (ASCII码)</td>
</tr>
<tr>
<td><code>110xxxxx</code> <code>10xxxxxx</code></td>
</tr>
<tr>
<td><code>1110xxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code></td>
</tr>
<tr>
<td><code>11110xxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code></td>
</tr>
</tbody></table>
</li>
<li><p>注意：技术人员在开发时都应该使用UTF-8编码</p>
</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>ASCII字符集：只有英文、数字、符号等，占1个字节</li>
<li>GBK字符集：汉字占2个字节，英文、数字占1个字节</li>
<li>UTF-8字符集：汉字占3个字节，英文、数字占1个字节</li>
<li>注意1：字符编码时使用的字符集，和解码时使用的字符集必须一致，否则会出现乱码</li>
<li>注意2：英文、数字一般不会出现乱码，英文很多字符集都兼容ASCII编码</li>
</ul>
</li>
</ol>
<h3 id="字符集的编码、解码操作"><a href="#字符集的编码、解码操作" class="headerlink" title="字符集的编码、解码操作"></a>字符集的编码、解码操作</h3><ol>
<li><p>Java代码完成对字符的编码</p>
<table>
<thead>
<tr>
<th align="center">String提供了如下方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>byte[] getBytes()</code></td>
<td align="center">使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中</td>
</tr>
<tr>
<td align="center"><code>byte[] getBytes(String charsetName)</code></td>
<td align="center">使用指定的字符集将String编码为一系列字节，将结果存储到新的字节数组中</td>
</tr>
</tbody></table>
</li>
<li><p>Java代码完成对字符的解码</p>
<table>
<thead>
<tr>
<th align="center">String提供了如下方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>String(byte[] bytes)</code></td>
<td align="center">通过平台的默认字符集解码指定的字节数组来构造新的String</td>
</tr>
<tr>
<td align="center"><code>String(byte[] bytes, String charsetName)</code></td>
<td align="center">通过指定的字符集解码指定的字节数组来构造新的String</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h2><ol>
<li><p>IO流：输入输出流，读写数据的</p>
<ul>
<li><p><code>I</code>指Input，称为输入流：负责把数据读到内存中去</p>
</li>
<li><p><code>O</code>指Output，称为输出流：负责写数据出去</p>
</li>
</ul>
</li>
<li><p>怎么学IO流：</p>
<ul>
<li>先搞清楚IO流的分类、体系</li>
<li>再挨个学习每个IO流的作用、用法</li>
</ul>
</li>
<li><p>IO流的分类：</p>
<ul>
<li><p>按流的方向分为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">	IO流 --&gt; 输入流</span><br><span class="line">	IO流 --&gt; 输出流</span><br></pre></td></tr></table></figure>
</li>
<li><p>按流中数据的最小单位，分为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">	IO流 --&gt; 字节流 --&gt; 适合操作所有类型文件</span><br><span class="line">	IO流 --&gt; 字符流 --&gt; 只适合操作纯文本文件</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
<li><p>IO流总体来看就有四大流：</p>
<ul>
<li>字节输入流：以内存为基准，来自磁盘文件&#x2F;网络中的数据以字节的形式读入到内存中去的流</li>
<li>字节输出流：以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流</li>
<li>字符输入流：以内存为基准，来自磁盘文件&#x2F;网络中的数据以字符的形式读入到内存中去的流</li>
<li>字符输出流：以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络中去的流</li>
</ul>
</li>
</ul>
</li>
<li><p>IO流的体系：</p>
<ul>
<li><p><code>java.io</code>包下：四大类流都是抽象类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">	IO流体系 --&gt; 字节流</span><br><span class="line">	IO流体系 --&gt; 字符流</span><br><span class="line">	字节流 --&gt; 字节输入流\InpuStream --&gt; FileInpuStream</span><br><span class="line">	字节流 --&gt; 字节输出流\OutpuStream --&gt; FileOutpuStream</span><br><span class="line">	字符流 --&gt; 字符输入流\Reader --&gt; FileReader</span><br><span class="line">	字符流 --&gt; 字符输出流\Writer --&gt; FileWriter</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><ul>
<li>字节流非常适合做一切文件的复制操作：任何文件的底层都是字节，字节流做复制，是一字不漏的转移完全部字节，只要复制后的文件格式一致就没有问问题</li>
</ul>
<h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><ol>
<li><p>作用：以内存为基准，来自磁盘文件的数据以字节的形式读入到内存中去</p>
</li>
<li><p>构造方法：</p>
<table>
<thead>
<tr>
<th align="center">构造方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public FileInputStream(File file)</code></td>
<td align="center">创建字节输入流管道与源文件接通</td>
</tr>
<tr>
<td align="center"><code>public FileInputStream(String pathname)</code></td>
<td align="center">创建字节输入流管道与源文件接通</td>
</tr>
</tbody></table>
</li>
<li><p>常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public int read()</code></td>
<td align="center">每次读取一个字节返回，如果发现没有数据可读会返回-1</td>
</tr>
<tr>
<td align="center"><code>public int read(byte[] bytes)</code></td>
<td align="center">每次使用一个字节数组去读取数据，返回字节数组读取了多少个字节，如果发现没有数据可读会返回-1</td>
</tr>
</tbody></table>
</li>
<li><p>注意事项：</p>
<ul>
<li>使用<code>FileInputStream</code>每次读取一个字节，读取性能较差，并且读取汉字输出会乱码</li>
<li>使用<code>FileInputStream</code>每次读取多个字节，读取性能得到了提升，但读取汉字还是会输出会乱码</li>
</ul>
</li>
<li><p>一次读完读取完全部字节</p>
<ul>
<li><p>方式一：定义一个与文件一样大的字节数组，一次性读取完文件的全部字节 </p>
</li>
<li><p>方式二：Java官方为<code>InputStream</code>提供了如下方法，可以直接把文件的全部字节读取到一个字节数组中返回。</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public byte[] readAllBytes() throws IOException</code></td>
<td align="center">直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>读取文本内容更适合字符流，字节流适合做数据的转移，如：文件复印等</p>
</li>
</ol>
<h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><ol>
<li><p>作用：以内存为基准，把内存中的数据以字节的形式写出到文件中去</p>
</li>
<li><p>构造方法：</p>
<table>
<thead>
<tr>
<th align="center">构造方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public FileOutStream(File file)</code></td>
<td align="center">创建字节输出流管道与源文件对象接通</td>
</tr>
<tr>
<td align="center"><code>public FileOutStream(String filepath)</code></td>
<td align="center">创建字节输出流管道与源文件对象接通</td>
</tr>
<tr>
<td align="center"><code>public FileOutStream(File file, boolean append)</code></td>
<td align="center">创建字节输出流管道与源文件对象接通，可追加数据</td>
</tr>
<tr>
<td align="center"><code>public FileOutStream(String filepath, boolean append)</code></td>
<td align="center">创建字节输出流管道与源文件对象接通，可追加数据</td>
</tr>
</tbody></table>
</li>
<li><p>常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public void write(int a)</code></td>
<td align="center">写一个字节出去</td>
</tr>
<tr>
<td align="center"><code>public void write(byte[] buffer)</code></td>
<td align="center">写一个字节数组出去</td>
</tr>
<tr>
<td align="center"><code>public void write(byte[] buffer, int pos, int len)</code></td>
<td align="center">写一个字节数组的一部分出去</td>
</tr>
<tr>
<td align="center"><code>public void close() throws IOException</code></td>
<td align="center">关闭流</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="释放资源的方式"><a href="#释放资源的方式" class="headerlink" title="释放资源的方式"></a>释放资源的方式</h3><ul>
<li><p><code>try-catch-finally</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    e.prntStackTrace();</span><br><span class="line">&#125; fianlly&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finally代码区的特点：不论try中的程序是否正常执行，最后一定会执行finally区，除非JVM终止。</p>
<p>作用：一般用于在程序执行完后进行资源的释放操作（专业级做法）。</p>
</li>
<li><p><code>try-with-resource</code>：JDK7开始提供了更简单的资源释放方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(定义资源<span class="number">1</span>, 定义资源<span class="number">2</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>该资源使用完毕后，会自动调用其<code>close()</code>方法，完成对资源的释放！</li>
<li><code>()</code>中只能放置资源对象(流对象)。</li>
<li>实现接口<code>AutoCloseable</code>的对象称之为资源对象，资源都会有一个<code>close()</code>方法</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java_常用API(二)</title>
    <url>/2023/10/02/Java_%E5%B8%B8%E7%94%A8API(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="Math、System、Runtime"><a href="#Math、System、Runtime" class="headerlink" title="Math、System、Runtime"></a>Math、System、Runtime</h1><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><ol>
<li><p>Math：代表数学，是一个工具类，里面提供的都是对数据进行操作的一些静态方法。</p>
</li>
<li><p>Math类提供的常见方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static int abs(int a)</code></td>
<td align="center">获取参数的绝对值</td>
</tr>
<tr>
<td align="center"><code>public static double ceil(double a)</code></td>
<td align="center">向上取整</td>
</tr>
<tr>
<td align="center"><code>public static double floor(double a)</code></td>
<td align="center">向下取整</td>
</tr>
<tr>
<td align="center"><code>public static int round(float a)</code></td>
<td align="center">四舍五入</td>
</tr>
<tr>
<td align="center"><code>public static int max(int a, int b)</code></td>
<td align="center">获取两个int值中的较大值</td>
</tr>
<tr>
<td align="center"><code>public static double pow(double a, double b)</code></td>
<td align="center">返回a的b次幂的值</td>
</tr>
<tr>
<td align="center"><code>public static double random()</code></td>
<td align="center">返回值为double的随机值，范围[0.0,  1.0)</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><ol>
<li><p>System：代表程序所在的系统，也是一个工具类。</p>
</li>
<li><p>System类提供的常见方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static void exit(int status)</code></td>
<td align="center">终止当前运行的Java虚拟机</td>
</tr>
<tr>
<td align="center"><code>public static long currentTimeMillis()</code></td>
<td align="center">返回当前系统的时间毫秒值形式</td>
</tr>
</tbody></table>
<ul>
<li>时间毫秒值：从1970-1-1 00:00:00 开始走到此刻的总毫秒值</li>
</ul>
</li>
</ol>
<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><ol>
<li><p>Runtime：代表程序所在的运行环境，Runtime是一个单例类</p>
</li>
<li><p>Runtime类提供的常见方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static Runtime getRuntime()</code></td>
<td align="center">返回与当前Java应用程序关联的运行时对象</td>
</tr>
<tr>
<td align="center"><code>public void exit(int status)</code></td>
<td align="center">终止当前运行的虚拟机</td>
</tr>
<tr>
<td align="center"><code>public int availableProcessors()</code></td>
<td align="center">返回Java虚拟机可用的处理器数</td>
</tr>
<tr>
<td align="center"><code>public long totalMemory()</code></td>
<td align="center">返回Java虚拟机中的内存总量</td>
</tr>
<tr>
<td align="center"><code>public long freeMemory()</code></td>
<td align="center">返回Java虚拟机中的可用内存</td>
</tr>
<tr>
<td align="center"><code>public Process exec(String command)</code></td>
<td align="center">启动某个程序，并返回代表该程序的对象</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h1><ul>
<li>BigDecimal：用于解决浮点型运算时，出现结果失真的问题</li>
</ul>
<h2 id="BigDecimal的构造方法"><a href="#BigDecimal的构造方法" class="headerlink" title="BigDecimal的构造方法"></a>BigDecimal的构造方法</h2><table>
<thead>
<tr>
<th align="center">构造方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public BigDecimal(double val)</code></td>
<td align="center">将double转换为BigDecimal</td>
</tr>
<tr>
<td align="center"><code>public BigDecimal(String val)</code></td>
<td align="center">将String转成BigDecimal</td>
</tr>
</tbody></table>
<p>注意：不推荐使用<code>public BigDecimal(double val)</code>创建对象，会导致精度损失</p>
<h2 id="BigDecimal的常用方法"><a href="#BigDecimal的常用方法" class="headerlink" title="BigDecimal的常用方法"></a>BigDecimal的常用方法</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static BigDecimal valueOf(double val)</code></td>
<td align="center">将double转换为BigDecimal</td>
</tr>
<tr>
<td align="center"><code>public BigDecimal add(BigDecimal b)</code></td>
<td align="center">加法</td>
</tr>
<tr>
<td align="center"><code>public BigDecimal subtract(BigDecimal b)</code></td>
<td align="center">减法</td>
</tr>
<tr>
<td align="center"><code>public BigDecimal multiply(BigDecimal b)</code></td>
<td align="center">乘法</td>
</tr>
<tr>
<td align="center"><code>public BigDecimal divide(BigDecimal b)</code></td>
<td align="center">除法</td>
</tr>
<tr>
<td align="center"><code>public BigDecimal divide(另一个BigDecimal对象, 精确几位, 舍入模式)</code></td>
<td align="center">除法、可以控制精确到小数几位</td>
</tr>
<tr>
<td align="center"><code>public double doubleValue()</code></td>
<td align="center">将BigDecimal转换成double</td>
</tr>
</tbody></table>
<h1 id="JDK8之前传统的日期和时间"><a href="#JDK8之前传统的日期和时间" class="headerlink" title="JDK8之前传统的日期和时间"></a>JDK8之前传统的日期和时间</h1><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><ol>
<li><p>Date：代表的时日期和时间。</p>
</li>
<li><p>Date的构造方法：</p>
<table>
<thead>
<tr>
<th align="center">构造方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public Date()</code></td>
<td align="center">创建一个Date对象，代表的是系统当前此刻日期时间</td>
</tr>
<tr>
<td align="center"><code>public Date(long time)</code></td>
<td align="center">把时间毫秒值转换成Date日期对象</td>
</tr>
</tbody></table>
</li>
<li><p>Date常见方法：</p>
<table>
<thead>
<tr>
<th align="center">常见方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public void getTime()</code></td>
<td align="center">返回从1970年1月1日 00:00:00走到此刻的总毫秒数</td>
</tr>
<tr>
<td align="center"><code>public void setTime(long time)</code></td>
<td align="center">设置日期对象的时间为当前时间毫秒值对应的时间</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h2><ol>
<li><p>SimpleDateFormat：代表简单日期格式化，可以用来把日期对象、时间毫秒值格式化成我们想要的形式。</p>
</li>
<li><p>SimpleDateFormat的常见构造方法：</p>
<table>
<thead>
<tr>
<th align="center">常见构造方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public SimpleDateFormat(String pattern)</code></td>
<td align="center">创建简单日期格式化对象，并封装时间的格式</td>
</tr>
</tbody></table>
</li>
<li><p>SimpleDateFormat的常见方法：</p>
<table>
<thead>
<tr>
<th align="center">格式化时间的方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public final String format(Date date)</code></td>
<td align="center">将日期格式化成日期&#x2F;时间字符串</td>
</tr>
<tr>
<td align="center"><code>public final String format(Object time)</code></td>
<td align="center">将时间毫秒值式化成日期&#x2F;时间字符串</td>
</tr>
<tr>
<td align="center"><code>public Date parse(String source)</code></td>
<td align="center">把字符串时间解析成日期对象</td>
</tr>
</tbody></table>
</li>
<li><p>时间格式的常见符号：</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">y</td>
<td align="center">年</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">月</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">日</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">时</td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">分</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">秒</td>
</tr>
<tr>
<td align="center">EEE</td>
<td align="center">星期</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">上午&#x2F;下午</td>
</tr>
</tbody></table>
<ul>
<li>yyyy-MM-dd HH:mm:ss  —————   2023-09-27 20:55:11</li>
</ul>
</li>
</ol>
<h2 id="Calender"><a href="#Calender" class="headerlink" title="Calender"></a>Calender</h2><ol>
<li><p>Calender：代表的是系统此刻时间对应的日历。通过它可以单独获取，修改时间中的年、月、日、时、分、秒等。</p>
</li>
<li><p>Calender日历类的常见方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static Calender getInstance()</code></td>
<td align="center">获取当前日历对象</td>
</tr>
<tr>
<td align="center"><code>public int get(int field)</code></td>
<td align="center">获取日历中的某个信息</td>
</tr>
<tr>
<td align="center"><code>public final Date getTime()</code></td>
<td align="center">获取日期对象</td>
</tr>
<tr>
<td align="center"><code>public long getTmeMillis()</code></td>
<td align="center">获取时间毫秒值</td>
</tr>
<tr>
<td align="center"><code>public void set(int field, int value)</code></td>
<td align="center">修改日历的某个信息</td>
</tr>
<tr>
<td align="center"><code>public void add(int field, int amount)</code></td>
<td align="center">为某个信息增加&#x2F;减少指定的值</td>
</tr>
</tbody></table>
<p>注意：calender是可变对象，一旦修改后其对象本身表示的时间将产生变化。</p>
</li>
</ol>
<h1 id="JDK8开始新增的日期和时间"><a href="#JDK8开始新增的日期和时间" class="headerlink" title="JDK8开始新增的日期和时间"></a>JDK8开始新增的日期和时间</h1><h2 id="为什么要学新增的时间？"><a href="#为什么要学新增的时间？" class="headerlink" title="为什么要学新增的时间？"></a>为什么要学新增的时间？</h2><ol>
<li>JDK8传统的时间API<ul>
<li>设计不合理，使用不方便，很多都被淘汰了。</li>
<li>都是可变对象，修改后会丢失最开始的时间。</li>
<li>线程不安全</li>
<li>只能精确到毫秒</li>
</ul>
</li>
<li>JDK8开始后新增的API<ul>
<li>设计更合理，功能丰富，使用方便</li>
<li>都是不可变对象，修改后会返回新的时间对象，不会丢失最开始的时间</li>
<li>线程安全</li>
<li>能精确到毫秒、纳秒</li>
</ul>
</li>
</ol>
<h2 id="LocalDate、LocalTime、LocalDateTime"><a href="#LocalDate、LocalTime、LocalDateTime" class="headerlink" title="LocalDate、LocalTime、LocalDateTime"></a>LocalDate、LocalTime、LocalDateTime</h2><ul>
<li><p>LocalDate：代表本地日期（年、月、日、星期）</p>
</li>
<li><p>LocalTime：代表本地时间（时、分、秒、纳秒）</p>
</li>
<li><p>LocalDateTime：代表本地日期、时间（年、月、日、星期、时、分、秒、纳秒）</p>
</li>
<li><p>他们获取对象的方法：</p>
<ul>
<li><code>public statie Xxxx now() 获取系统当前时间对应的该对象</code></li>
<li><code>public statie Xxxx of() 获取指定时间对应的该对象</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> LocalDate.of(<span class="number">2035</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> LocalTime.of(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2035</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p>LocalDate的常用API：</p>
<ul>
<li><p>获取日期</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public int getYear()</code></td>
<td align="center">获取年</td>
</tr>
<tr>
<td align="center"><code>public int getMonthValue()</code></td>
<td align="center">获取月份（1-12）</td>
</tr>
<tr>
<td align="center"><code>public int getDayOfMonth()</code></td>
<td align="center">获取日</td>
</tr>
<tr>
<td align="center"><code>public int getDayOfYear()</code></td>
<td align="center">获取当前是一年中的第几天</td>
</tr>
<tr>
<td align="center"><code>public DayOfWeek getDayOfWeek()</code></td>
<td align="center">获取星期几：<code>ld.getDayOfWeek().getValue()</code></td>
</tr>
</tbody></table>
</li>
<li><p>修改日期</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">withYear、withMonth 、withDayOfMonth、withDayOfYear</td>
<td align="center">直接修改某个信息，返回新的日期对象</td>
</tr>
<tr>
<td align="center">plusYears、plusMonths、plusDays、plusWeeks</td>
<td align="center">把某个信息加多少，返回新的日期对象</td>
</tr>
<tr>
<td align="center">minusYears、minusMonths、minusDays、minusWeeks</td>
<td align="center">把某个信息减多少，返回新的日期对象</td>
</tr>
<tr>
<td align="center">equals、isBefore、isAfter</td>
<td align="center">判断两个日期对象，是否相等、在前还是在后</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>LocalTime的常用API：</p>
<ul>
<li><p>获取时间</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public int getHour()</code></td>
<td align="center">获取小时</td>
</tr>
<tr>
<td align="center"><code>public int getMinute()</code></td>
<td align="center">获取分</td>
</tr>
<tr>
<td align="center"><code>public int getSecond()</code></td>
<td align="center">获取秒</td>
</tr>
<tr>
<td align="center"><code>public int getNano()</code></td>
<td align="center">获取纳秒</td>
</tr>
</tbody></table>
</li>
<li><p>修改时间</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">withHour、withMinute、withSecond、withNano</td>
<td align="center">直接修改某个信息，返回新的时间对象</td>
</tr>
<tr>
<td align="center">plusHours、plusMinutes、plusSeconds、plusNanos</td>
<td align="center">把某个信息加多少，返回新的时间对象</td>
</tr>
<tr>
<td align="center">minusHours、minusMinutes、minusSeconds、minusNanos</td>
<td align="center">把某个信息减多少，返回新的时间对象</td>
</tr>
<tr>
<td align="center">equals、isBefore、isAfter</td>
<td align="center">判断两个时间对象，是否相等、在前还是在后</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>LocalDateTime的常用API：</p>
<ul>
<li><p>包含<em>LocalDate</em>和<em>LocalTime</em>的所有方法！</p>
</li>
<li><p>LocalDateTime提供的格式化、解析时间的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public String format(DateTimeFormatter formatter)</code></td>
<td align="center">格式化时间</td>
</tr>
<tr>
<td align="center"><code>public static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter)</code></td>
<td align="center">解析时间</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<h2 id="ZoneId、ZoneDateTime"><a href="#ZoneId、ZoneDateTime" class="headerlink" title="ZoneId、ZoneDateTime"></a>ZoneId、ZoneDateTime</h2><ul>
<li>ZoneId：代表时区Id</li>
<li>ZoneDateTime：带时区的时间</li>
</ul>
<ol>
<li><p>ZoneId时区的常见方法</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static Set&lt;String&gt; getAvailableZoneIds()</code></td>
<td align="center">获取Java中支持的所有时区</td>
</tr>
<tr>
<td align="center"><code>public static systemDefault()</code></td>
<td align="center">获取系统默认时区</td>
</tr>
<tr>
<td align="center"><code>public static ZoneId of(String zoneId)</code></td>
<td align="center">获取一个指定时区</td>
</tr>
</tbody></table>
</li>
<li><p>ZonedDateTime带时区时间的常见方法</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static ZonedDateTime now()</code></td>
<td align="center">获取当前时区的ZoneDateTime对象</td>
</tr>
<tr>
<td align="center"><code>public static ZoneDateTime now(ZoneId zone)</code></td>
<td align="center">获取指定时区的ZoneDateTime对象</td>
</tr>
<tr>
<td align="center">getYear、getMonthValue、getDayOfMonth、getDayOfYear、getDayOfWeek、getHour、getMinute、getSecond、getNano</td>
<td align="center">获取年、月、日、时、分、秒、纳秒</td>
</tr>
<tr>
<td align="center"><code>public ZonedDateTime withXxx</code></td>
<td align="center">修改时间系列的方法</td>
</tr>
<tr>
<td align="center"><code>public ZonedDateTime plusXxx</code></td>
<td align="center">增加时间系列的方法</td>
</tr>
<tr>
<td align="center"><code>public ZonedDateTime plusXxx</code></td>
<td align="center">减少时间系列的方法</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h2><ol>
<li><p>Instant：代表时间线上的某个时刻&#x2F;时间戳</p>
</li>
<li><p>通过获取Instant的对象可以拿到此刻的时间，该事件由两部分组成：从1970-01-01 00:00:00 开始走到此刻的总秒数 + 不够1秒的纳秒数</p>
</li>
<li><p>作用：做代码的性能分析，或者记录用户的操作时间点</p>
</li>
<li><p>Instant的常见方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static Instant now()</code></td>
<td align="center">获取当前时间的Instant对象（标准时间）</td>
</tr>
<tr>
<td align="center"><code>public long getrEpochSecond()</code></td>
<td align="center">获取1970-01-01 00:00:00 开始记录的秒数</td>
</tr>
<tr>
<td align="center"><code>public int getNano()</code></td>
<td align="center">从时间线开始，获取从第二个开始的纳秒数</td>
</tr>
<tr>
<td align="center">plusMillis、plusSeconds、plusNanos</td>
<td align="center">增加时间系列的方法</td>
</tr>
<tr>
<td align="center">minusMillis、minusSeconds、minusNanos</td>
<td align="center">减少时间系列的方法</td>
</tr>
<tr>
<td align="center">equals、isBefore、isAfter</td>
<td align="center">判断两个时间对象，是否相等、在前还是在后</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h2><ol>
<li><p>DateTimeFormatter：格式化器，用于时间的格式化、解析，线程安全</p>
</li>
<li><p>DateTimeFormatter的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static DateTimeFormatter ofPattern(时间格式)</code></td>
<td align="center">获取格式化时间对象</td>
</tr>
<tr>
<td align="center"><code>public String format(时间对象)</code></td>
<td align="center">格式化时间</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h2><ol>
<li><p>Period：计算时期间隔（年、月、日），用于计算两个LocalDate对象 相差的年数、月数、天数。</p>
</li>
<li><p>Period常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static Period between(LocalDate start, LocalDate end)</code></td>
<td align="center">传入2个日期对象，得到Period对象</td>
</tr>
<tr>
<td align="center"><code>public int getYears()</code></td>
<td align="center">计算隔几年，并返回</td>
</tr>
<tr>
<td align="center"><code>public int getMonths()</code></td>
<td align="center">计算隔几个月，并返回</td>
</tr>
<tr>
<td align="center"><code>public int getDays()</code></td>
<td align="center">计算隔几天，并返回</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h2><ol>
<li><p>Duration：可以用于计算两个时间对象相差的天数、小时数、分数、秒数、纳秒数；支持LocalTime、LocalDateTime、Instant等时间。</p>
</li>
<li><p>Duration常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static Duration between(start, end)</code></td>
<td align="center">传入2个日期对象，得到Duration对象</td>
</tr>
<tr>
<td align="center"><code>public long toDays()</code></td>
<td align="center">计算隔多少天，并返回</td>
</tr>
<tr>
<td align="center"><code>public long toHours()</code></td>
<td align="center">计算隔多少小时，并返回</td>
</tr>
<tr>
<td align="center"><code>public long toMinutes()</code></td>
<td align="center">计算隔多少分，并返回</td>
</tr>
<tr>
<td align="center"><code>public long toSeconds()</code></td>
<td align="center">计算隔多少秒，并返回</td>
</tr>
<tr>
<td align="center"><code>public long toMillis()</code></td>
<td align="center">计算隔多少毫秒，并返回</td>
</tr>
<tr>
<td align="center"><code>public long toNaos()</code></td>
<td align="center">计算隔多少纳秒，并返回</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><ol>
<li><p>Arrays：用来操作数组的一个工具类。</p>
</li>
<li><p>Arrays类类提供的常见方法：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static String toString(类型[] arr)</code></td>
<td align="center">返回数组的内容</td>
</tr>
<tr>
<td align="center"><code>public static int[] copyOfRange(类型[], 起始索引, 结束索引)</code></td>
<td align="center">拷贝数组（指定范围）</td>
</tr>
<tr>
<td align="center"><code>public static copyOf(类型[] arr, int newLength)</code></td>
<td align="center">拷贝数组</td>
</tr>
<tr>
<td align="center"><code>public static setAll(double[] array, IntToDoubleFunction gererator)</code></td>
<td align="center">把数组中的原数据改为新数据</td>
</tr>
<tr>
<td align="center"><code>public static void sort(类型[] arr)</code></td>
<td align="center">对数组进行排序（默认是升序排序）</td>
</tr>
</tbody></table>
<ol start="3">
<li>如果数组中存储的是对象，如何排序？</li>
</ol>
<ul>
<li><p>方法一：让该对象的类实现<code>comparable</code>(比较规则)接口，然后重写<code>compareTo</code>方法，自己制定比较规则</p>
</li>
<li><p>方法二：使用下面这个<code>sort</code>方法，创建<code>Comparator</code>比较器接口的匿名内部类对象，然后自己制定比较规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] arr, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java_常用API(一)</title>
    <url>/2023/09/27/Java_%E5%B8%B8%E7%94%A8API(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><ol>
<li>什么是API？<ul>
<li>全称应用程序编程接口（Application Programming interface）</li>
<li>就是Java自己写好的程序，给程序员调用，方便完成一些功能</li>
</ul>
</li>
<li>API文档：程序使用说明书</li>
</ol>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><ol>
<li>什么是包？<ul>
<li>包是用来分门别类的管理各种不同程序的，类似于文件夹，建包有利于程序的管理与维护。</li>
<li>建包的语法格式：如：<code>package com.local.project;</code></li>
</ul>
</li>
<li>在自己程序中调用其他包下的程序的注意事项<ul>
<li>如果当前程序中，要调用自己所在包下的其他程序，可以直接调用。（同一个包下的类，互相可以直接调用）</li>
<li>如果当前程序中，要调用其他包下的程序，则必须在当前程序中导包，才可以访问！导包格式：<code>import 包名.类名;</code></li>
<li>如果当前程序中，要调用Java提供的程序，也需要先导包才可以使用；但<code>java.lang</code>包下的程序是不需要我们导包的，可以直接使用</li>
<li>如果当前程序，要调用多个不同包下的程序，而这些程序名正好一样，此时默认只能导入一个程序，另一个程序必须带包名访问</li>
</ul>
</li>
</ol>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String创建对象封装字符串数据的方式"><a href="#String创建对象封装字符串数据的方式" class="headerlink" title="String创建对象封装字符串数据的方式"></a>String创建对象封装字符串数据的方式</h2><ol>
<li><p>方式一：Java程序中的所有字符串文字（例如：”abc”）都为此类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="string">&quot;沈阳&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：调用String类的构造方法初始化字符串对象</p>
<table>
<thead>
<tr>
<th align="center">构造方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public String()</code></td>
<td align="center">创建一个空白字符串对象，不含任何内容</td>
</tr>
<tr>
<td align="center"><code>public String(String original)</code></td>
<td align="center">根据传入的字符串内容，来创建字符串对象</td>
</tr>
<tr>
<td align="center"><code>public String(char[] chars)</code></td>
<td align="center">根据字符数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td align="center"><code>public String(byte[] byte)</code></td>
<td align="center">根据字节数组的内容，来创建字符串对象</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="String的常用方法"><a href="#String的常用方法" class="headerlink" title="String的常用方法"></a>String的常用方法</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public int length()</code></td>
<td align="center">获取字符串的长度返回（就是字符个数）</td>
</tr>
<tr>
<td align="center"><code>public char charAt(int index)</code></td>
<td align="center">获取某个索引处的字符返回</td>
</tr>
<tr>
<td align="center"><code>public char[] toCharArray()</code></td>
<td align="center">将当前字符串转换成字符数组返回</td>
</tr>
<tr>
<td align="center"><code>public boolean equals(Object anObject)</code></td>
<td align="center">判断当前字符串与另一个字符串的内容是否一样，一样返回true</td>
</tr>
<tr>
<td align="center"><code>public boolean equalsIgnoreCase(String anotherString)</code></td>
<td align="center">判断当前字符串与另一个字符串的内容是否一样（忽略大小写）</td>
</tr>
<tr>
<td align="center"><code>public String substring(int beginIndex, int endINdex)</code></td>
<td align="center">根据开始和结束索引处截取，得到新的字符串返回</td>
</tr>
<tr>
<td align="center"><code>public String substring(int beginIndex)</code></td>
<td align="center">从传入的索引处截取，截取到末尾，得到新的字符串返回</td>
</tr>
<tr>
<td align="center"><code>public String replace(CharSequence target, CharSequence replcaement)</code></td>
<td align="center">使用新值，将字符串中的旧值替换，得到新的字符串</td>
</tr>
<tr>
<td align="center"><code>public boolean contains(String s)</code></td>
<td align="center">判断字符串中是否包含了某个字符串</td>
</tr>
<tr>
<td align="center"><code>public boolean startsWith(String s)</code></td>
<td align="center">判断字符串是否以某个字符串内容开头，开头则返回true，否则返回false</td>
</tr>
<tr>
<td align="center"><code>public String[] split(String regex)</code></td>
<td align="center">把字符串按照某个字符串内容分割，并返回字符串数组回来</td>
</tr>
</tbody></table>
<h2 id="String使用时的注意事项"><a href="#String使用时的注意事项" class="headerlink" title="String使用时的注意事项"></a>String使用时的注意事项</h2><ol>
<li>String是不可变字符串对象</li>
<li>只要使用<code>&quot;……&quot;</code>方式写出的字符串对象，会存储到字符串常量池，且相同内容的字符串只存储一份。</li>
<li>通过<code>new</code>方式创建的字符串对象，每<code>new</code>一次都会产生一个新的对象放在堆内存中</li>
</ol>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><ul>
<li>集合是一种容器，用来存储数据，且集合的大小可变</li>
<li>ArrayList<E>是用的最多、最常见的一种集合，它是泛型类，可以约束存储的数据类型。</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><table>
<thead>
<tr>
<th align="center">构造方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public ArrayList()</code></td>
<td align="center">创建一个空的集合对象</td>
</tr>
</tbody></table>
<h2 id="ArrayList的常用方法"><a href="#ArrayList的常用方法" class="headerlink" title="ArrayList的常用方法"></a>ArrayList的常用方法</h2><table>
<thead>
<tr>
<th align="center">常用方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public boolean add(E e)</code></td>
<td align="center">将指定的元素添加到次集合的末尾</td>
</tr>
<tr>
<td align="center"><code>public void add(int index, E element)</code></td>
<td align="center">在此集合中的指定位置插入指定的元素</td>
</tr>
<tr>
<td align="center"><code>public E get(int index)</code></td>
<td align="center">返回指定索引处的元素</td>
</tr>
<tr>
<td align="center"><code>public int size()</code></td>
<td align="center">返回集合中的元素个数</td>
</tr>
<tr>
<td align="center"><code>public E remove(int index)</code></td>
<td align="center">删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center"><code>public boolean remove(Object o)</code></td>
<td align="center">删除指定的元素，返回删除是否成功</td>
</tr>
<tr>
<td align="center"><code>public E set(int index,E element)</code></td>
<td align="center">修改指定索引处的元素，返回被修改的元素</td>
</tr>
</tbody></table>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>从前往后遍历删除时可能存在漏掉元素删除元素后，执行<code>i--</code>即可或者从后往前遍历</li>
</ul>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="Object类的作用"><a href="#Object类的作用" class="headerlink" title="Object类的作用"></a>Object类的作用</h2><ul>
<li>Object类是Java中所有类的祖宗类，因此，Java中所有类的对象都可以直接使用Object类中提供的一些方法。</li>
</ul>
<h2 id="Object类的常见方法"><a href="#Object类的常见方法" class="headerlink" title="Object类的常见方法"></a>Object类的常见方法</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public String toString()</code></td>
<td align="center">返回对象的字符串表示形式</td>
</tr>
<tr>
<td align="center"><code>public boolean equals(Object o)</code></td>
<td align="center">判断两个对象是否相等</td>
</tr>
<tr>
<td align="center"><code>protected Object clone()</code></td>
<td align="center">对象克隆</td>
</tr>
</tbody></table>
<ol>
<li><p><code>toString</code>方法的作用和意义</p>
<ul>
<li><p>基本作用：返回对象的字符串形式。</p>
</li>
<li><p>存在意义：让子类重写，一遍返回子类对象的内容。</p>
</li>
</ul>
</li>
<li><p><code>equals</code>方法的作用和意义</p>
<ul>
<li>基本作用：,默认是比较两个对象的地址是否相等。</li>
<li>存在意义：让子类从写，以便于比较对象的内容是否相同。</li>
</ul>
</li>
</ol>
<h1 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h1><ul>
<li>Objects是一个工具类，提供了很多操作对象的静态方法给我们使用</li>
</ul>
<h2 id="Objects类的常见方法"><a href="#Objects类的常见方法" class="headerlink" title="Objects类的常见方法"></a>Objects类的常见方法</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static boolean equals(Object a, Object b)</code></td>
<td align="center">先做非空判断，再比较两个对象</td>
</tr>
<tr>
<td align="center"><code>public static boolean isNull(Object obj)</code></td>
<td align="center">判断对象是否为<code>null</code>，为<code>null</code>返回<code>true</code>，反之</td>
</tr>
<tr>
<td align="center"><code>public static boolean nonNull(Object obj)</code></td>
<td align="center">判断对象是否不为<code>null</code>，不为<code>null</code>返回<code>true</code>，反之</td>
</tr>
</tbody></table>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><ul>
<li><p>包装类就是把基本数据类型包装成对象</p>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">对应的包装类（引用数据类型）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Charactor</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<ul>
<li>自动装箱：基本数据类型可以自动转换为包装类型</li>
<li>自动拆箱：包装类型可以自动转换为基本数据类型</li>
</ul>
</li>
</ul>
<h2 id="包装类的其他常见操作"><a href="#包装类的其他常见操作" class="headerlink" title="包装类的其他常见操作"></a>包装类的其他常见操作</h2><ul>
<li><p>可以把基本类型的数据转换成字符串类型</p>
<table>
<thead>
<tr>
<th>方法名</th>
</tr>
</thead>
<tbody><tr>
<td><code>public static String toSpring(double d)</code></td>
</tr>
<tr>
<td><code>public String toSpring()</code></td>
</tr>
</tbody></table>
</li>
<li><p>可以把字符串类型的数值转换成数值本身对应的数据类型</p>
<table>
<thead>
<tr>
<th>方法名</th>
</tr>
</thead>
<tbody><tr>
<td><code>public static int parseInt(String s)</code></td>
</tr>
<tr>
<td><code>public static Integer valueOf(String s)</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><ul>
<li>StringBuilder代表可变字符串对象，相当于是一个容器，它里面装的字符串是可以改变的，就是用来操作字符串的。</li>
<li>好处：StringBuilder比String更适合做字符串的修改操作，效率会更高，代码也会更简洁。</li>
<li>对于字符串相关操作，如频繁的拼接、修改等，建议使用StringBuilder，效率更高</li>
<li>注意：如果操作字符串较少，或者不需要操作，以及定义字符串变量，还是建议使用String</li>
</ul>
<h2 id="StringBuilder的构造方法"><a href="#StringBuilder的构造方法" class="headerlink" title="StringBuilder的构造方法"></a>StringBuilder的构造方法</h2><table>
<thead>
<tr>
<th align="center">构造方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public StringBuilder()</code></td>
<td align="center">创建一个空白的可变字符串对象，不包含任何内容</td>
</tr>
<tr>
<td align="center"><code>public StringBuilder(String str)</code></td>
<td align="center">创建一个指定字符串内容的可变字符串对象</td>
</tr>
</tbody></table>
<h2 id="StringBuilder的常用方法"><a href="#StringBuilder的常用方法" class="headerlink" title="StringBuilder的常用方法"></a>StringBuilder的常用方法</h2><table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public StringBuilder append(任意类型)</code></td>
<td align="center">添加数据并返回StringBuilder对象本身</td>
</tr>
<tr>
<td align="center"><code>public StringBuilder reverse()</code></td>
<td align="center">将对象的内容反转</td>
</tr>
<tr>
<td align="center"><code>public int length()</code></td>
<td align="center">返回对象的内容长度</td>
</tr>
<tr>
<td align="center"><code>public String toString()</code></td>
<td align="center">通过toString()就可以实现把StringBuilder转换为String</td>
</tr>
</tbody></table>
<h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><ul>
<li>StringBuffer的用法与StringBuilder是一模一样的</li>
<li>但StringBuilder是线程不安全的，StringBuffer是线程安全</li>
</ul>
<h1 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h1><ul>
<li>JDK8开始才有的，跟StringBuilder一样，也是用来操作字符串的，也可以看成是一个容器，创建后里面的内容是可变的。</li>
<li>好处：不仅能提高字符串的操作效率，并且在有些场景下使用它操作字符串，代码会更简洁</li>
</ul>
<h2 id="StringJoiner的构造方法"><a href="#StringJoiner的构造方法" class="headerlink" title="StringJoiner的构造方法"></a>StringJoiner的构造方法</h2><table>
<thead>
<tr>
<th align="center">构造方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public StringJoiner()</code></td>
<td align="center">创建一个StringJoiner对象，指定拼接时的间隔符号</td>
</tr>
<tr>
<td align="center"><code>public StringJoiner(间隔符号, 开始符号, 结束符号)</code></td>
<td align="center">创建一个StringJoiner对象，指定拼接时的间隔符号、开始符号、结束符号</td>
</tr>
</tbody></table>
<h2 id="StringJoiner的常用方法"><a href="#StringJoiner的常用方法" class="headerlink" title="StringJoiner的常用方法"></a>StringJoiner的常用方法</h2><table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public StringJoiner add(添加的内容)</code></td>
<td align="center">添加数据，并返回对象本身</td>
</tr>
<tr>
<td align="center"><code>public int length()</code></td>
<td align="center">返回长度（字符出现的个数）</td>
</tr>
<tr>
<td align="center"><code>public String toString()</code></td>
<td align="center">返回一个字符串（该字符串就是拼接之后的结果）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java_算法、正则表达式、异常</title>
    <url>/2023/10/05/Java_%E7%AE%97%E6%B3%95%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol>
<li><p>每次从数组中找出最大值放在数组的后面去。</p>
</li>
<li><p>冒牌排序的步骤分析：</p>
<ul>
<li>确定总共需要做几轮：数组的长度 - 1</li>
<li>每轮比较几次：数组长度 - 轮次 - 1</li>
<li>当前位置数据大于后一位置则交换数据，否则不进行操作</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">     	<span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">			temp = arr[j];</span><br><span class="line">             arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">             arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ol>
<li><p>每轮选择当前位置，开始找出后面的较小值，与该位置交换</p>
</li>
<li><p>选择排序的步骤分析：</p>
<ul>
<li>确定总共需要选择几轮：数组长度 -1</li>
<li>控制每轮从当前位置为基准，与后面元素选择几次</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> temp, p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">     p = i;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length ; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[p] &gt; arr[j])&#123;</span><br><span class="line">              p = j;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (i != p)&#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[p];</span><br><span class="line">            arr[p] = temp;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="二分查找法（折半查找）"><a href="#二分查找法（折半查找）" class="headerlink" title="二分查找法（折半查找）"></a>二分查找法（折半查找）</h3><ol>
<li><p>前提：数组中的数据必须是有序的</p>
</li>
<li><p>核心思想：每次排除一半的数据，查询数据的性能明显提高极多</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> data)</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> ,right = arr.length;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right + left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (data &lt; arr[mid])&#123;</span><br><span class="line">            right = mid -<span class="number">1</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (data &gt; arr[mid])&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>正则表达式：就是由一些指定的字符组成，代表的是一个规则</li>
<li>作用：<ul>
<li>用来校验数据格式是否合法</li>
<li>在一段文本中查找满足要求的内容</li>
</ul>
</li>
</ol>
<h2 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h2><ol>
<li><p>String类提供了<code>public boolean matches(String regex)</code>方法与正则表达式进行匹配。</p>
</li>
<li><p>正则表达式书写规则：</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">含义</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>[]</code></td>
<td align="center">里面的内容出现一次</td>
<td align="center"><code>[abc]</code></td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">取反</td>
<td align="center"><code>[^abc]</code></td>
</tr>
<tr>
<td align="center"><code>&amp;&amp;</code></td>
<td align="center">交集，不能写单个的&amp;</td>
<td align="center"><code>[a-z&amp;&amp;m-p]</code></td>
</tr>
<tr>
<td align="center"><code>.</code></td>
<td align="center">任意字符</td>
<td align="center"><code>\n回车符号不匹配</code></td>
</tr>
<tr>
<td align="center"><code>\</code></td>
<td align="center">转义字符</td>
<td align="center"><code>\\d</code></td>
</tr>
<tr>
<td align="center"><code>\\d</code></td>
<td align="center">0-9</td>
<td align="center"><code>\\d+</code></td>
</tr>
<tr>
<td align="center"><code>\\D</code></td>
<td align="center">非0-9</td>
<td align="center"><code>\\D+</code></td>
</tr>
<tr>
<td align="center"><code>\\s</code></td>
<td align="center">空白字符</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>\\S</code></td>
<td align="center">非空白字符</td>
<td align="center"><code>^\S</code></td>
</tr>
<tr>
<td align="center"><code>\\w</code></td>
<td align="center">单词字符</td>
<td align="center"><code>[a-zA-Z_0-9]</code></td>
</tr>
<tr>
<td align="center"><code>\\W</code></td>
<td align="center">非单词字符</td>
<td align="center"><code>[^\w]</code></td>
</tr>
<tr>
<td align="center"><code>()</code></td>
<td align="center">分组</td>
<td align="center"><code>a(bc)+</code></td>
</tr>
<tr>
<td align="center">&#96;</td>
<td align="center">&#96;</td>
<td align="center">写在括号外表示并集</td>
</tr>
<tr>
<td align="center"><code>?</code></td>
<td align="center">0次或1次</td>
<td align="center"><code>\\d?</code></td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td align="center">0次或多次</td>
<td align="center"><code>\\d*</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center">1次或多次</td>
<td align="center"><code>\\d+</code></td>
</tr>
<tr>
<td align="center"><code>&#123;&#125;</code></td>
<td align="center">具体次数</td>
<td align="center"><code>a&#123;7&#125;</code></td>
</tr>
<tr>
<td align="center"><code>(?i)</code></td>
<td align="center">忽略后面字符的大小写</td>
<td align="center"><code>(?i)abc</code></td>
</tr>
<tr>
<td align="center"><code>a((?i)b)c</code></td>
<td align="center">只忽略b的大小写</td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="认识异常"><a href="#认识异常" class="headerlink" title="认识异常"></a>认识异常</h2><ol>
<li><p>Error：代表系统级别错误（属于严重问题）</p>
</li>
<li><p>Exception：叫异常，它代表的才是我们程序可能出现的问题，所以，<code>Exception</code>以及它的子类来封装程序出现的问题。</p>
<ul>
<li>运行时异常：<code>RuntimeException</code>及其子类，编译阶段不会出现错误提醒，运行时出现的异常（如：数组索引越界异常）</li>
<li>编译时异常：编译阶段就会出现错误提醒的（如：日期解析异常）</li>
</ul>
</li>
<li><p>异常处理方法：</p>
<ul>
<li><p>抛出异常（throws）：在方法上使用throws关键字，可以将方法内部出现的异常抛出去给调用者处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法 <span class="keyword">throws</span> 异常<span class="number">1</span>, 异常<span class="number">2</span>,……&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>捕获异常（try……catch）：直接捕获程序出现的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 监视可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量)&#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量)&#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;……</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ol>
<li>自定义异常：Java无法将世界上全部问题都提供异常类来代表，如果企业遇到自己的某种问题，想通过异常来表示，以便用异常来管理该问题，那就需要自己来定义异常类了。</li>
<li>自定义异常的种类：自定义运行时异常、自定义编译时异常</li>
<li>自定义运行时异常：<ul>
<li>定义一个异常类继承<code>RuntimeException</code></li>
<li>重写构造方法</li>
<li>通过<code>throw new 异常类(xxx)</code>来创建异常对象并抛出。编译阶段不报错，提醒不强烈，运行时才可能出现</li>
</ul>
</li>
<li>自定义编译时异常：<ul>
<li>定义一个异常类继承<code>Exception</code></li>
<li>重写构造方法</li>
<li>通过<code>throw new 异常类(xxx)</code>来创建异常对象并抛出。编译阶段就报错，提醒更强烈</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java_集合框架(二)</title>
    <url>/2023/11/05/Java_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li><p>Map集合称为双列集合，格式：{key1&#x3D;value1, key2&#x3D;value2, key3&#x3D;value3,…… }，一次需要存一对数据作为一个元素</p>
</li>
<li><p>Map集合的每个元素“key &#x3D; value”称为一个键值对&#x2F;键值对对象&#x2F;一个Entry对象，Map集合也被叫做“键值对集合”</p>
</li>
<li><p>Map集合的所有键是不允许重复的，但值可以重复，键和值是一一对应的，每个键只能找到自己对应的值</p>
</li>
<li><p>应用场景：需要存储一一对应的数据时，就可以考虑使用Map集合来做</p>
</li>
<li><p>Map集合体系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">    Map--&gt;HashMap</span><br><span class="line">    Map--&gt;......</span><br><span class="line">    Map--&gt;TreeMap</span><br><span class="line">    HashMap--&gt;LinkedHashMap</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map集合体系特点：</p>
<ul>
<li>注意：Map系列集合的特点都是由键决定的，值只是一个附属品，值是不做要求的</li>
<li>HashMap（由键决定特点）：无序、不重复、无索引（用的最多）</li>
<li>LinkedHashMap（由键决定特点）：由键决定的特点：有序、不重复、无索引。</li>
<li>TreeMap（由键决定特点）：按照大小默认升序排序、不重复、无索引。</li>
</ul>
</li>
</ol>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol>
<li><p>为什么要先学习Map的常用方法？</p>
<ul>
<li>由于Map是双列集合的祖宗，它的功能是全部双列集合都可以继承过来使用的</li>
</ul>
</li>
<li><p>Map的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public V put(K key, V value)</code></td>
<td align="center">添加元素</td>
</tr>
<tr>
<td align="center"><code>public int size()</code></td>
<td align="center">获取集合的大小</td>
</tr>
<tr>
<td align="center"><code>public void clear()</code></td>
<td align="center">清空集合</td>
</tr>
<tr>
<td align="center"><code>public boolean isEmpty()</code></td>
<td align="center">判断集合是否为空，为空返回true，反之</td>
</tr>
<tr>
<td align="center"><code>public V get(Object key)</code></td>
<td align="center">根据键获取对应值</td>
</tr>
<tr>
<td align="center"><code>public V remove()</code></td>
<td align="center">根据键删除整个元素</td>
</tr>
<tr>
<td align="center"><code>public boolean containsKey(Object key)</code></td>
<td align="center">判断是否包含某个键</td>
</tr>
<tr>
<td align="center"><code>public boolean containsValue(Object value)</code></td>
<td align="center">判断是否包含某个值</td>
</tr>
<tr>
<td align="center"><code>public Set&lt;K&gt; keySet()</code></td>
<td align="center">获取全部键的集合</td>
</tr>
<tr>
<td align="center"><code>public Collection&lt;V&gt; values()</code></td>
<td align="center">获取Map集合的全部值</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><ol>
<li><p>Map集合的遍历方式：</p>
<ul>
<li>键找值：先获取Map集合全部的键，再通过遍历键来找值</li>
<li>键值对：把“键值对”看成一个整体进行遍历（难度较大）</li>
<li>Lambda：JDK1.8 开始之后的新技术（非常的简单）</li>
</ul>
</li>
<li><p>键找值：</p>
<ul>
<li><p>使用该方法遍历map集合，需要用到以下方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public Set&lt;K&gt; keySet()</code></td>
<td align="center">获取所有键的集合</td>
</tr>
<tr>
<td align="center"><code>public V get(Object key)</code></td>
<td align="center">根据键获取其对应的值</td>
</tr>
</tbody></table>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String key : keys)&#123;</span><br><span class="line">	<span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">	System.out.println(key + <span class="string">&quot;--&gt;&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>键值对：</p>
<ul>
<li><p>使用该方法遍历map集合，需用到以下方法：</p>
<table>
<thead>
<tr>
<th align="center">Map提供的方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Set&lt;Map.Entey&lt;K, V&gt;&gt; entrySet()</code></td>
<td align="center">获取所有“键值对”的集合</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Map.Entry提供的方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>K getKey()</code></td>
<td align="center">获取键</td>
</tr>
<tr>
<td align="center"><code>V getValue()</code></td>
<td align="center">获取值</td>
</tr>
</tbody></table>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; entry : entries) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">	<span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">	System.out.println(key + <span class="string">&quot;--&gt;&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Lambda：</p>
<ul>
<li><p>使用该方法遍历map集合，需用到以下方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>default void forEach(BiConsumer&lt;? K, ? super V&gt; action)</code></td>
<td align="center">结合lambda遍历Map集合</td>
</tr>
</tbody></table>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda表达式前代码</span></span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, Double&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String key, Double value)</span> &#123;</span><br><span class="line">    	System.out.println(key + <span class="string">&quot;--&gt;&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Lambda表达式简化</span></span><br><span class="line">map.forEach((key, value )-&gt;&#123;</span><br><span class="line">	System.out.println(key + <span class="string">&quot;--&gt;&quot;</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><pre><code>  1. HashMap特点：无序、不重复、无索引（用的最多）
  2. HashMap和跟HashSet的底层原理是一模一样的，都是基于哈希表实现的
  3. 实际上：原来学的Set系列集合的底层就是基于Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。
  4. 哈希表：
  - JDK8之前，哈希表 = 数组 + 链表
  - JDK8之后，哈希表 = 数组 + 链表 + 红黑树
  - 哈希表是一种增删改查数据，性能都较好的数据结构
  5. HashMap底层原理是基于哈希表实现的
  - HashMap集合是一种增删改查数据，性能都较好的集合
  - 但是它是无序，不能重复，没有索引支持的（由键值决定特点）
  - HashMap的键依赖`hashCode`和`equals`方法保证键的唯一
  - 如果键存储的是自定义类型的对象，可以通过重写`hashCode`和`equals`方法，这样可以保证多个对象内容一样时，HashMap集合就能认为是重复的。
</code></pre>
<h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><ol>
<li>LinkedHashMap特点：由键决定的特点：有序、不重复、无索引。</li>
<li>LinkedHashMap集合的底层数据结构依然是基于哈希表实现的，只是每个键值对元素又额外多了一个双链表机制记录元素顺序（保证有序）。</li>
<li>实际上：原来学的LinkedHashSet集合的底层原理就是LinkedHashMap。</li>
</ol>
<h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><ol>
<li><p>TreeMap特点：不重复、无索引、可排序（按照键的大小默认升序排序，只能对键排序）</p>
</li>
<li><p>原理：TreeMap和TreeSet集合的底层原理是一样的，都是基于红黑树实现的排序。</p>
</li>
<li><p>TreeMap集合同样也支持两种方式来指定排序规则</p>
<ul>
<li>让类实现<code>Comparable</code>接口，重写比较规则。</li>
<li>TreeMap集合有一个有参构造器，支持创建<code>Comparator</code>比较器对象，以便来指定比较规则。</li>
</ul>
</li>
</ol>
<h1 id="补充知识：集合的嵌套"><a href="#补充知识：集合的嵌套" class="headerlink" title="补充知识：集合的嵌套"></a>补充知识：集合的嵌套</h1><ol>
<li>集合嵌套：指的是集合中的元素又是一个集合</li>
</ol>
<h1 id="JDK8新特性：Stream"><a href="#JDK8新特性：Stream" class="headerlink" title="JDK8新特性：Stream"></a>JDK8新特性：Stream</h1><h2 id="认识Stream流"><a href="#认识Stream流" class="headerlink" title="认识Stream流"></a>认识Stream流</h2><ol>
<li><p>什么是Stream？</p>
<ul>
<li>也叫Stream流，是JDK8开始新增的一套API（java.util.stream.*），可以用于操作集合或者数组的数据。</li>
<li>优势：Stream流大量结合了Lambda的语法风格来编程，提供了一种更加强大，更加简单的方式操作集合或者数组的数据，代码更简洁，可读性更好</li>
</ul>
</li>
<li><p>Stream流的使用步骤：</p>
<p><img src="/../image/Stream%E6%B5%81%E6%B5%81%E7%A8%8B.png"></p>
</li>
</ol>
<h2 id="Stream流的常用方法"><a href="#Stream流的常用方法" class="headerlink" title="Stream流的常用方法"></a>Stream流的常用方法</h2><ol>
<li><p>获取Stream流</p>
<ul>
<li><p>获取 集合 的Stream流</p>
<table>
<thead>
<tr>
<th align="center">Collection提供的如下方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>default Stream&lt;E&gt; stream()</code></td>
<td align="center">获取当前集合对象的Stream流</td>
</tr>
</tbody></table>
</li>
<li><p>获取 数组 的Stream流</p>
<table>
<thead>
<tr>
<th align="center">Arrays类提供的如下方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)</code></td>
<td align="center">获取当前数组的Stream流</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Stream类提供的如下方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static &lt;T&gt; Stream&lt;T&gt; of(T... values)</code></td>
<td align="center">获取当前接收数据的Stream</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>Stream流常见的中间方法</p>
<ul>
<li><p>中间方法指的是调用完会返回新的Stream流，可以继续使用（支持链式编程）</p>
<table>
<thead>
<tr>
<th align="center">Stream提供的常用中间方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></td>
<td align="center">用于对流中的数据进行过滤</td>
</tr>
<tr>
<td align="center"><code>Stream&lt;T&gt; sorted()</code></td>
<td align="center">对元素进行升序排序</td>
</tr>
<tr>
<td align="center"><code>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</code></td>
<td align="center">按照指定规则排序</td>
</tr>
<tr>
<td align="center"><code>Stream&lt;T&gt; limit(long maxSize)</code></td>
<td align="center">获取前几个对象</td>
</tr>
<tr>
<td align="center"><code>Stream&lt;T&gt; skip(long n)</code></td>
<td align="center">跳过前几个对象</td>
</tr>
<tr>
<td align="center"><code>Stream&lt;T&gt; distinct()</code></td>
<td align="center">去除流中重复的元素</td>
</tr>
<tr>
<td align="center"><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, extends R&gt; mapper)</code></td>
<td align="center">对元素进行加工，并返回对应的新流</td>
</tr>
<tr>
<td align="center"><code>static &lt;T&gt; Stream&lt;T&gt; concat(Stream a, Stream b)</code></td>
<td align="center">合并a和b两个流为一个流</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>Stream流常见的终结方法</p>
<ul>
<li><p>终结方法指的是调用完成后，不会返回新的Stream了，没法继续使用流了。</p>
<table>
<thead>
<tr>
<th align="center">Stream提供的常用终结方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>void forEach(Consumer action)</code></td>
<td align="center">对此流运算后的元素执行遍历</td>
</tr>
<tr>
<td align="center"><code>long count()</code></td>
<td align="center">统计此流运算后的元素个数</td>
</tr>
<tr>
<td align="center"><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code></td>
<td align="center">获取此流运算后的最大值元素</td>
</tr>
<tr>
<td align="center"><code>Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)</code></td>
<td align="center">获取此流运算后的最小值元素</td>
</tr>
</tbody></table>
</li>
<li><p>收集Stream流：就是把Stream流操作后的结果传回到集合或者数组中去返回。</p>
<p>Sream流：方便操作集合&#x2F;数组的手段； 集合&#x2F;数组：才是开发中的目的。</p>
<table>
<thead>
<tr>
<th align="center">Stream提供的常见终结方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>R collect(Collector collector)</code></td>
<td align="center">把流处理后的结果收集到一个指定的集合中去</td>
</tr>
<tr>
<td align="center"><code>Object[] toArray()</code></td>
<td align="center">把流处理后的结果收集到一个数组中去</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Collectors工具类提供了具体的收集方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static &lt;T&gt; Collector toList()</code></td>
<td align="center">把元素收集到List集合中</td>
</tr>
<tr>
<td align="center"><code>public static &lt;T&gt; Collector toSet()</code></td>
<td align="center">把元素收集到Set集合中</td>
</tr>
<tr>
<td align="center"><code>public static Collector toMap(Function keyMapper, Function valueMapper)</code></td>
<td align="center">把元素收集到Map集合中</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>注意：流只能收集一次</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础(一)——入门</title>
    <url>/2023/09/08/Java%E5%9F%BA%E7%A1%80(%E4%B8%80)%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="初识Java"><a href="#初识Java" class="headerlink" title="初识Java"></a>初识Java</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><ul>
<li>Java是美国SUN公司在1995年推出的一门计算机高级编程语言</li>
<li>Java早期称为Oak，后期改名为Java</li>
<li>Java之父：詹姆斯·高斯林 （James Gosling）</li>
<li>2009年sun公司被Oracle公司收购</li>
</ul>
<h2 id="Java用途"><a href="#Java用途" class="headerlink" title="Java用途"></a>Java用途</h2><ul>
<li>桌面应用开发</li>
<li>企业级应用开发</li>
<li>移动应用开发</li>
<li>服务器系统</li>
<li>大数据开发</li>
<li>游戏开发</li>
</ul>
<h2 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h2><table>
<thead>
<tr>
<th align="center">技术体系</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Java SE（Java Standard Edition）：标准版</td>
<td align="center">Java技术的核心和基础</td>
</tr>
<tr>
<td align="center">Java EE（Java Enterprise Edition）：企业版</td>
<td align="center">企业级应用开发的一套解决方案</td>
</tr>
<tr>
<td align="center">Java ME（Java Micro Edition）：小型版</td>
<td align="center">针对移动应用的解决方案</td>
</tr>
</tbody></table>
<h2 id="JDK的安装与下载"><a href="#JDK的安装与下载" class="headerlink" title="JDK的安装与下载"></a>JDK的安装与下载</h2><ol>
<li>要使用java，必须先在<a href="https://www.oracle.com/cn/java/technologies/downloads/">Oracle官网</a>安装JDK（Java Development Kit），即开发者工具包</li>
<li>最好下载JDK的LTS(长期支持版)版本</li>
<li>在命令行窗口，输入<code>java -version</code>、<code>javac -version</code>看版本号</li>
<li>JDK中最重要的2个命令程序：<ul>
<li>javac：编译工具</li>
<li>java：执行工具</li>
</ul>
</li>
</ol>
<h2 id="DOS窗口常见命令的使用"><a href="#DOS窗口常见命令的使用" class="headerlink" title="DOS窗口常见命令的使用"></a>DOS窗口常见命令的使用</h2><table>
<thead>
<tr>
<th align="center">常用命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">D:</td>
<td align="center">切换到某个盘符下：<code>D:</code>、<code>C:</code></td>
</tr>
<tr>
<td align="center">dir</td>
<td align="center">查看当前路径下的文件信息</td>
</tr>
<tr>
<td align="center">cd</td>
<td align="center">进入单级目录：<code>cd 笔记</code>     进入多级目录：<code>d F:\笔记</code>      回退到上级目录：<code>cd..</code>      回退到盘符根目录：<code>cd\  </code></td>
</tr>
<tr>
<td align="center">cls</td>
<td align="center">清屏</td>
</tr>
</tbody></table>
<h2 id="Java程序开发的三个步骤"><a href="#Java程序开发的三个步骤" class="headerlink" title="Java程序开发的三个步骤"></a>Java程序开发的三个步骤</h2><ol>
<li>三个步骤：<ul>
<li>编写代码：</li>
<li>编译代码：使用<code>javac</code>编译，生成后缀名为<code>.class</code>的字节码文件</li>
<li>运行代码</li>
</ul>
</li>
<li>注意事项：<ul>
<li>第一个java程序建议使用记事本书写</li>
<li>建议代码文件全英文，首字母大写，使用驼峰命名法，源代码文件后缀必须是<code>.java</code></li>
<li>文件名称必须与代码的类名称一致</li>
</ul>
</li>
</ol>
<h1 id="JDK的组成、跨平台原理"><a href="#JDK的组成、跨平台原理" class="headerlink" title="JDK的组成、跨平台原理"></a>JDK的组成、跨平台原理</h1><h2 id="JDK组成"><a href="#JDK组成" class="headerlink" title="JDK组成"></a>JDK组成</h2><ul>
<li>JVM（Java Virtual Machine）：java虚拟机，真正运行java程序的地方</li>
<li>核心类库：Java自己写好的程序，给程序员自己的程序调用</li>
<li>JRE（Java Runtime Environment）：Java的运行环境，JVM和核心类库合称JRE</li>
<li>JDK（Java Development Kit）：Java开发工具包，包含上面所有</li>
</ul>
<h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><ul>
<li>Java一次编译、处处可用</li>
<li>Java程序只需要开发一次，就可以在各种安装了JVM的系统平台上运行</li>
</ul>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol>
<li><p>什么是是注释：</p>
<p>写在程序中对程序进行解释说明的文字</p>
</li>
<li><p>语法：</p>
<ul>
<li>单行注释：<code>// 单行注释</code></li>
<li>多行注释：<code>/* 多行注释 */</code></li>
<li>文档注释：<code>/** 这是文档注释 */</code></li>
</ul>
</li>
<li><p>注释的特点：</p>
<p>不影响程序的执行，编译后的字节码文件已经没有注释了</p>
</li>
<li><p>注释的快捷键：</p>
<p><code>Ctrl + /</code> 对选中的内容进行单行注释</p>
</li>
</ol>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><ol>
<li><p>什么是字面量：</p>
<p>计算机中用来处理数据的，字面量就是告诉程序员：数据在程序中的书写格式。</p>
</li>
<li><p>常用数据</p>
<table>
<thead>
<tr>
<th align="center">常用数据</th>
<th align="center">写法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整数</td>
<td align="center">666，88</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">小数</td>
<td align="center">13.14</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">字符</td>
<td align="center"><code>‘A’</code>、<code>&#39;好&#39;</code></td>
<td align="center">必须使用单引号，有且仅能一个字符</td>
</tr>
<tr>
<td align="center">字符串</td>
<td align="center"><code>&quot;坚持&quot;</code></td>
<td align="center">必须使用双引号，内容可有可无</td>
</tr>
<tr>
<td align="center">布尔值</td>
<td align="center">true、false</td>
<td align="center">只有两个值：true代表真，false代表假</td>
</tr>
<tr>
<td align="center">空值</td>
<td align="center">null</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">转义字符</td>
<td align="center"><code>\n</code>、<code>\t</code></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol>
<li><p>变量是什么，完整的定义格式语法</p>
<ul>
<li>变量是用来储存一个数据的，本质是内存中的一块区域</li>
<li>语法：<code>数据类型 变量名称 = 数据;</code></li>
</ul>
</li>
<li><p>为啥要用变量，变量有啥好处？</p>
<p>使用变量记要处理的数据，编写代码更灵活，管理代码更方便</p>
</li>
<li><p>变量特点：变量里面装的数据可以被替换</p>
</li>
<li><p>注意：</p>
<ul>
<li>变量要先声明。才能使用</li>
<li>什么类型的变量，只能储存什么类型的数据</li>
<li>变量存在访问范围，同一个范围内，多个变量的名字不能一样</li>
<li>变量定义时可以不给赋初始值；但在使用时，变量里必须有值。</li>
<li>变量的赋值必须写在方法里面</li>
</ul>
</li>
</ol>
<h2 id="关键字、标识符"><a href="#关键字、标识符" class="headerlink" title="关键字、标识符"></a>关键字、标识符</h2><ol>
<li>关键字：<ul>
<li>关键字就是Java自己要用到的词，并且有特殊含义的一些词。</li>
<li>我们不能将关键字用来做为：类名、变量名，否则会报错</li>
</ul>
</li>
<li>标识符：<ul>
<li>标识符就是名字</li>
<li>标识的规则：由数字、字母、下划线、美元符等组成，且不能数字开头，不能用关键字作为名字</li>
</ul>
</li>
</ol>
<h1 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h1><h2 id="变量里的数据在计算机中的存储原理"><a href="#变量里的数据在计算机中的存储原理" class="headerlink" title="变量里的数据在计算机中的存储原理"></a>变量里的数据在计算机中的存储原理</h2><ol>
<li><p>数据在计算机底层都是采用二进制存储的</p>
</li>
<li><p>计算机底层表示数据的最小单元时字节，一个字节等于8个二进制位</p>
</li>
<li><p>字符数据在计算机中时怎么存的：</p>
<p>字符存的是ASCII码表中对应的数字的二进制形式</p>
</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>基本数据类型：4大类8种<ul>
<li>整形：byte、short、int、long</li>
<li>浮点型：float、double</li>
<li>字符型：char</li>
</ul>
</li>
<li>引用数据类型：String</li>
<li>注意：<ul>
<li>定义long类型数据要在数字后面加L&#x2F;l</li>
<li>定义float类型数据要在后面加F&#x2F;f</li>
<li>八进制数据以0开头</li>
<li>十六进制数据以0x开头</li>
</ul>
</li>
</ol>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><ol>
<li><p>为什么要进行类型转换？</p>
<p>存在不同类型的变量赋值给其他类型的变量</p>
</li>
<li><p>什么是自动类型转换？</p>
<p>类型范围小的变量，可以直接赋值给范围大的变量</p>
</li>
</ol>
<h2 id="表达式的自动类型转换"><a href="#表达式的自动类型转换" class="headerlink" title="表达式的自动类型转换"></a>表达式的自动类型转换</h2><ol>
<li><p>表达式的自动类型转换是什么样的？</p>
<p>低精度的类型会自动转换成高精度的类型运算</p>
</li>
<li><p>表达式的最终结果类型是由谁决定的？</p>
<p>最终类型由表达式中的最高类型决定</p>
</li>
<li><p>byte、short、char是直接转换成int类型参与运算</p>
</li>
</ol>
<h2 id="强制类型转化"><a href="#强制类型转化" class="headerlink" title="强制类型转化"></a>强制类型转化</h2><ol>
<li>什么是强制类型转换？<ul>
<li>默认情况下，高精度的变量直接赋值给低精度的变量会报错</li>
<li>可以强行将高精度的变量、数据赋值给类型范围小的变量</li>
<li>语法：<code>数据类型 变量 = (数据类型)变量/数据</code></li>
</ul>
</li>
<li>强制类型转换有哪些需要注意的？<ul>
<li>可能出现数据丢失</li>
<li>小数强制转换成整数直接截断小数保留整数</li>
</ul>
</li>
</ol>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ol>
<li><p>基本的算术运算符</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">作用</th>
<th align="center">补充</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">加</td>
<td align="center">除了加法外，”+”还可以用来连接字符串</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;</td>
<td align="center">除</td>
<td align="center">在Java中两个整数相除结果还是整数</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">取余</td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p>自增自减运算符：只能操作变量，不能操作字面量</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">++</td>
<td align="center">自增，对变量自身的值加1</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">自减，对变量自身的值减1</td>
</tr>
</tbody></table>
</li>
<li><p>赋值运算符</p>
<ul>
<li>基本运算符：<code>=</code></li>
<li>复合赋值运算符：<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code></li>
<li>补充：复合赋值运算符自带强制类型转换</li>
</ul>
</li>
<li><p>关系运算符</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;&#x3D;</td>
<td align="center">判断内容是否相等，满足为True，否则为False</td>
</tr>
<tr>
<td align="center">!&#x3D;</td>
<td align="center">判断内容是否不相等，满足为True，否则为False</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">判断内容左侧内容是否大于右侧，满足为True，否则为False</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">判断内容左侧内容是否小于右侧，满足为True，否则为False</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td align="center">判断内容左侧内容是否大于等于右侧，满足为True，否则为False</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="center">判断内容左侧内容是否小于等于右侧，满足为True，否则为False</td>
</tr>
</tbody></table>
</li>
<li><p>逻辑运算符</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">叫法</th>
<th align="center">运算逻辑</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="center">逻辑与</td>
<td align="center">多个条件都需都是true，结果方为true</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">逻辑或</td>
<td align="center">多个条件有一个是true，结果就是true</td>
</tr>
<tr>
<td align="center">!</td>
<td align="center">逻辑非</td>
<td align="center">取反</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">逻辑异或</td>
<td align="center">相同为false，不同为false</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>&amp;：有一个为false，结果为false</li>
<li>&amp;&amp;：有一个为false，结果为false，但前一个为false后，后一个条件就不执行了</li>
<li>|：有一个为true，结果是true</li>
<li>||：有一个为true，结果是true，但前一个为true后，后一个条件就不执行了</li>
</ul>
</li>
<li><p>三元运算符</p>
<ul>
<li>格式：<code>条件表达式?值1:值2</code></li>
<li>执行流程：首先计算条件表达式的值，如果值为true，返回值1，如果为false，返回值2</li>
</ul>
</li>
</ol>
<h1 id="API介绍、Scanner"><a href="#API介绍、Scanner" class="headerlink" title="API介绍、Scanner"></a>API介绍、Scanner</h1><ol>
<li>API是什么？API文档是什么？<ul>
<li>Application Programming Interface，应用程序编程接口：Java写好的程序，可以直接调用</li>
<li>Java提供的程序使用说明书</li>
</ul>
</li>
<li>Scanner：<ul>
<li>作用：接收用户键盘输入的数据</li>
<li>使用步骤：<ol>
<li>导包：<code>import java.util.Scanner;</code></li>
<li>创建对象：<code>Scanner sc = new Scanner(System in);</code></li>
<li>定义变量接收用户输入的数据：<code>int age = sc.nextInt();</code>、<code>String name = sc.next();</code></li>
</ol>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java_集合框架(一)</title>
    <url>/2023/11/02/Java_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol>
<li><p>集合：集合是一种容器，用来装数据的，类似于数组，但集合的大小可变，开发中也非常常用。为了满足不同的业务场景需求，Java还提供了很多不同特点的集合给我们选择。</p>
</li>
<li><p>集合体系结构：</p>
<ul>
<li><p>单列集合：每个元素（数据）只包含一个值</p>
<p><code>Collection</code>，<code>List</code>，<code>ArrayList</code>，<code>LinkedList</code>，<code>Set</code>，<code>HashSet</code>，<code>LinkedHashSet</code>，<code>TreeSet</code></p>
</li>
<li><p>双列集合：每个元素包括两个值（键值对）</p>
<p><code>Map</code>，<code>HashMap</code>，<code>TreeMap</code>，<code>LinedHashMap</code>。</p>
</li>
</ul>
</li>
<li><p>Collection集合体系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">    Collection--&gt;List</span><br><span class="line">    Collection--&gt;Set</span><br><span class="line">    List--&gt;ArrayList</span><br><span class="line">    List--&gt;LinkedList</span><br><span class="line">	Set--&gt;HashSet</span><br><span class="line">	HashSet--&gt;LinkedHashSet</span><br><span class="line">	Set--&gt;TreeSet</span><br></pre></td></tr></table></figure>
</li>
<li><p>Collection集合特点：</p>
<ul>
<li>List系列集合：添加的元素是有序的、可重复、有索引<ul>
<li>ArrayList、LinkedList：有序、可重复、有索引</li>
</ul>
</li>
<li>Set系列集合：添加的元素是无序的，不重复、无索引<ul>
<li>HashSet：无序、不重复、无索引</li>
<li>LinkedHashSet：有序、不重复、无索引</li>
<li>TreeSet：按照大小默认升序排序、不重复、无索引</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><h2 id="Collection的常用方法"><a href="#Collection的常用方法" class="headerlink" title="Collection的常用方法"></a>Collection的常用方法</h2><ol>
<li><p>为什么要先学Collection的常用方法？</p>
<ul>
<li>Collection是单列结合是祖宗，它规定的方法（功能）是全部单列集合都会继承的。</li>
</ul>
</li>
<li><p>Collection的常见方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public boolean add(E e)</code></td>
<td align="center">把给定的对象添加到当前集合中</td>
</tr>
<tr>
<td align="center"><code>public void clear()</code></td>
<td align="center">清空集合中所有的元素</td>
</tr>
<tr>
<td align="center"><code>public boolean remove(E e)</code></td>
<td align="center">把给定的对象在当前集合中删除</td>
</tr>
<tr>
<td align="center"><code>public boolean contains(Object obj)</code></td>
<td align="center">判断当前集合中是否包含给定的对象</td>
</tr>
<tr>
<td align="center"><code>public boolean isEmpty()</code></td>
<td align="center">判断当前集合是否为空</td>
</tr>
<tr>
<td align="center"><code>public int size()</code></td>
<td align="center">返回集合中元素的个数</td>
</tr>
<tr>
<td align="center"><code>public Object[] toArray()</code></td>
<td align="center">把集合中的元素，存储到数组中</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="Collection的遍历方式"><a href="#Collection的遍历方式" class="headerlink" title="Collection的遍历方式"></a>Collection的遍历方式</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ol>
<li><p>迭代器概述</p>
<ul>
<li>迭代器是用来遍历集合的专用方式（数组没有迭代器），在Java中迭代器的代表是<code>Iterator</code>。</li>
</ul>
</li>
<li><p>Collection集合获取迭代器的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Iterator&lt;E&gt; iterator()</code></td>
<td align="center">返回集合中的迭代器对象，该迭代器对象默认指向当前集合的第一个元素</td>
</tr>
</tbody></table>
</li>
<li><p>Iterator迭代器中的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>boolean hasNext</code></td>
<td align="center">询问当前位置是否有元素存在，存在返回true，不存在返回false</td>
</tr>
<tr>
<td align="center"><code>E next()</code></td>
<td align="center">获取当前位置的元素，并同时将迭代器对象指向下一个元素处</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><ol>
<li><p>增强for循环的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 变量名: 数组或者集合)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String s :c)&#123;</span><br><span class="line">     System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增强for可以用来遍历集合或者数组</p>
</li>
<li><p>增强for遍历集合，本质就是迭代器遍历集合的简化写法</p>
</li>
</ol>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><ol>
<li><p>Lambda表达式遍历集合</p>
<ul>
<li>得益于JDK 8开始的新技术，提供了一种更简单、更直接的方式来遍历集合</li>
</ul>
</li>
<li><p>需要使用Collection的如下方法来完成</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>default void forEach(Consumer&lt;? super T&gt; action)</code></td>
<td align="center">结合lambda遍历集合</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><h2 id="特点、特有方法"><a href="#特点、特有方法" class="headerlink" title="特点、特有方法"></a>特点、特有方法</h2><ol>
<li><p>List系列集合特点：有序，可重复，有索引</p>
<ul>
<li>ArrayList：有序，可重复，有索引</li>
<li>LinkedList：有序，可重复，有索引</li>
<li>ArrayList和LinkedList底层采用的数据结构不同，应用场景不同</li>
</ul>
</li>
<li><p>List集合的特有方法</p>
<ul>
<li>List集合因为支持索引，所以多了很多与索引相关的方法，当然，Collection的功能List也都继承了</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>void add(int index, E element)</code></td>
<td align="center">在此集合中的指定位置插入指定元素</td>
</tr>
<tr>
<td align="center"><code>E remove(int index)</code></td>
<td align="center">删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center"><code>E set(int index, E element)</code></td>
<td align="center">修改指定索引处的元素，返回被修改的元素</td>
</tr>
<tr>
<td align="center"><code>E get(int index)</code></td>
<td align="center">返回指定索引处的元素</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><ol>
<li>for循环（因为List集合有索引）</li>
<li>迭代器</li>
<li>增强for循环</li>
<li>Lambda表达式</li>
</ol>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ol>
<li>ArrayList基于数组实现的，数组的特点：查询快、增删慢<ul>
<li>查询快：查询数据通过地址值和索引定位，查询任意数据耗时相同</li>
<li>删除效率低：可能需要把后面很多的数据进行前移</li>
<li>添加效率极低：可能需要把后面很多的数据后移，再添加元素；或者也可能需要进行数组的扩容</li>
</ul>
</li>
<li>ArrayList实现：<ul>
<li>利用无参构造器创建的集合，会在底层创建一个默认长度为0的数组</li>
<li>添加第一个元素时，底层会创建一个新的长度为10的数组</li>
<li>存满时，会扩容1.5倍</li>
<li>如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准</li>
</ul>
</li>
<li>ArrayList集合适合的应用场景<ul>
<li>ArrayList适合：根据索引查询数据，比如根据随机索引取数组（高效）或者数据量不是很大时</li>
<li>ArrayList不适合：数据量大的同时，又要频繁的进行增删操作</li>
</ul>
</li>
</ol>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ol>
<li><p>链表：链表中的节点是独立的对象，在内存中是不连续的，每个节点包含数据值和下一个节点的地址</p>
<p>特点：</p>
<ul>
<li>查询慢：无论查询哪个数据都要从头开始找</li>
<li>增删相对快</li>
</ul>
</li>
<li><p>LinkedList底层原理</p>
<ul>
<li>基于双链表实现（每个节点包含数据、前一个结点地址和后一个结点地址）</li>
<li>特点：查询慢，增删相对较快，但对首尾元素进行增删改查的速度是极快的</li>
</ul>
</li>
<li><p>LinkedList新增了很多首尾操作的特有方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public void addFirst(E e)</code></td>
<td align="center">在该列表开头插入指定的元素</td>
</tr>
<tr>
<td align="center"><code>public void addLast(E e)</code></td>
<td align="center">将指定的元素追加到此列表的末尾</td>
</tr>
<tr>
<td align="center"><code>public E getFirst()</code></td>
<td align="center">返回此列表中的第一个元素</td>
</tr>
<tr>
<td align="center"><code>public E getLast()</code></td>
<td align="center">返回此列表中的最后一个元素</td>
</tr>
<tr>
<td align="center"><code>public E removeFirst()</code></td>
<td align="center">在此列表中删除并返回第一个元素</td>
</tr>
<tr>
<td align="center"><code>public E removeLast()</code></td>
<td align="center">在此列表中删除并返回最后一个元素</td>
</tr>
</tbody></table>
</li>
<li><p>LinkedList的应用场景：</p>
<ul>
<li><p>设计队列（先进先出，后进后出）</p>
<p>数据进入队列的过程称为：入队</p>
<p>数据离开队列的过程称为：出队</p>
</li>
<li><p>设计栈（后进先出，先进后出）</p>
<p>数据进入栈模型的过程称为：压&#x2F;进站（push）</p>
<p>数据离开栈模型的过程称为：弹&#x2F;出栈（pop）</p>
</li>
</ul>
</li>
</ol>
<h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><h2 id="Set系列集合特点"><a href="#Set系列集合特点" class="headerlink" title="Set系列集合特点"></a>Set系列集合特点</h2><ol>
<li>Set系集合特点：无序：添加数据的顺序和获取出的数据顺序不一致；不重复；无索引；</li>
<li>HashSet：无序、不重复、无索引。</li>
<li>LinkedHashSet：有序、不重复、无索引。</li>
<li>TreeSet：排序、不重复、无索引。</li>
<li>注意：Set要用到的常用方法，基本上就是Collection提供的！！！自己几乎没有额外新增的一些常用方法！</li>
</ol>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ol>
<li>HashSet集合的底层原理：哈希表</li>
<li>HashSet集合去重复的机制<ul>
<li>HashSet集合默认不能对内容一样的两个不同对象去重复</li>
<li>如何让HashSet集合实现对内容一样的两个不同对象进行去重：重写<code>hashCode()</code>和<code>equals()</code>方法</li>
</ul>
</li>
</ol>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ol>
<li>LinkedHashSet集合底层原理：<ul>
<li>哈希表（数组、链表、红黑树）</li>
<li>但是，LinkedHashSet的每个元素都额外的多了一个双链表的机制记录它前后元素的位置</li>
</ul>
</li>
</ol>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ol>
<li><p>TreeSet底层基于红黑树实现</p>
</li>
<li><p>排序规则：</p>
<ul>
<li>对于数值类型：Integer，Double，默认按照数值大小的本身进行升序排序</li>
<li>对于字符串类型：默认按照首字母的编号升序排序</li>
<li>对于自定义类型的对象，TreeSet默认是无法直接排序的</li>
</ul>
</li>
<li><p>自定义排序规则</p>
<ul>
<li><p>方法一：让该对象的类实现<code>comparable</code>(比较规则)接口，然后重写<code>compareTo</code>方法，自己制定比较规则</p>
</li>
<li><p>方法二：通过调用TreeSet集合有参数构造器，可以设置Comparator（比较器对象，用于指定比较规则）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：如果类本身有实现Comparable接口，TreeSet集合同时也自带比较器，默认使用集合自带的比较器排序。</p>
</li>
</ul>
</li>
</ol>
<h1 id="Collection集合总结"><a href="#Collection集合总结" class="headerlink" title="Collection集合总结"></a>Collection集合总结</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>如果希望记住元素的添加顺序，需要存储重复的元素，又要频繁的根据索引查询数据？<ul>
<li>用ArrayList集合（有序、可重复、有索引)，底层基于数组的。(常用)</li>
</ul>
</li>
<li>如果希望记住元素的添加顺序，且增删首尾数据的情况较多?<ul>
<li>用LinkedList集合（有序、可重复、有索引)，底层基于双链表实现的。</li>
</ul>
</li>
<li>如果不在意元素顺序，也没有重复元素需要存储，只希望增删改查都快?<ul>
<li>用HashSet集合（无序，不重复，无索引)，底层基于哈希表实现的。(常用)</li>
</ul>
</li>
<li>如果希望记住元素的添加顺序，也没有重复元素需要存储，且希望增删改查都快?<ul>
<li>用LinkedHashSet集合（有序，不重复，无索引)，底层基于哈希表和双链表。</li>
</ul>
</li>
<li>如果要对元素进行排序，也没有重复元素需要存储?且希望增删改查都快?<ul>
<li>用TreeSet集合，基于红黑树实现。</li>
</ul>
</li>
</ol>
<h2 id="集合的并发修改异常问题"><a href="#集合的并发修改异常问题" class="headerlink" title="集合的并发修改异常问题"></a>集合的并发修改异常问题</h2><ol>
<li>集合的并发修改异常<ul>
<li>使用迭代器遍历集合时，又同时在删除集合中的数据，程序就会出现并发修改异常的错误。</li>
<li>由于增强for循环遍历集合就是迭代器遍历集合的简化写法，因此，使用增强for循环遍历集合，又在同时删除集合中的数据时，程序也会出现并发修改异常的错误</li>
</ul>
</li>
<li>怎么保证遍历集合同时删除数据时不出bug<ul>
<li>使用迭代器遍历集合，但用迭代器自己的删除方法删除数据即可。</li>
<li>如果能用for循环遍历时:可以倒着遍历并删除;或者从前往后遍历，但删除元素后做<code>i--</code>操作。</li>
</ul>
</li>
</ol>
<h2 id="Collection的其他相关知识"><a href="#Collection的其他相关知识" class="headerlink" title="Collection的其他相关知识"></a>Collection的其他相关知识</h2><h3 id="前置知识：可变参数"><a href="#前置知识：可变参数" class="headerlink" title="前置知识：可变参数"></a>前置知识：可变参数</h3><ol>
<li>可变参数：就是一种特殊形参，定义在方法、构造器的形参列表里，格式是：<code>数据类型...参数名称;</code></li>
<li>可变参数的特点和好处<ul>
<li>特点：可以不传数据给它;可以传一个或者同时传多个数据给它;也可以传一个数组给它。</li>
<li>好处：常常用来灵活的接收数据。</li>
</ul>
</li>
<li>注意实现：<ul>
<li>可变参数在方法内部就是一个数组。</li>
<li>一个形参列表中可变参数只能有一个。</li>
<li>可变参数必须放在形参列表的最后面。</li>
</ul>
</li>
</ol>
<h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><ol>
<li><p>Collections：是一个用来操作集合的工具类</p>
</li>
<li><p>Collections提供的常用静态方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T……elements)</code></td>
<td align="center">给集合批量添加元素</td>
</tr>
<tr>
<td align="center"><code>public static void shuffle(List&lt;?&gt; list)</code></td>
<td align="center">打乱List集合的元素顺序</td>
</tr>
<tr>
<td align="center"><code>public static &lt;T&gt; void sort(List&lt;?&gt; list)</code></td>
<td align="center">对List集合中的元素进行升序排序</td>
</tr>
<tr>
<td align="center"><code>public static &lt;T&gt; void sort(List&lt;?&gt; list, Comparator&lt;? super T&gt; c)</code></td>
<td align="center">对List集合中的元素，按照比较器对象指定的规则进行排序</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ol>
<li><p>哈希值</p>
<ul>
<li><p>就是一个int类型的数值，Java中每一个对象都有一个哈希值。</p>
</li>
<li><p>Java中的所有对象，都可以调用<code>Object</code>类提供的<code>hashCode</code>方法，返回该对象自己的哈希值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>：返回对象的哈希码值。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>对象哈希值的特点</p>
<ul>
<li>同一个对象多次调用<code>hashCode()</code>方法返回的哈希值是相同的。</li>
<li>不同对象，他们的哈希值一般不相同，但也有可能会相同（哈希碰撞）。</li>
</ul>
</li>
<li><p>哈希表</p>
<ul>
<li><p>哈希表是一种增删改查数据性能都较好的结构</p>
</li>
<li><p>JDK8之前，哈希表 &#x3D; 数组 + 链表</p>
<ol>
<li><p>创建一个默认长度16的数组，默认加载因子为0.75，数组名table</p>
</li>
<li><p>使用元素的哈希值对数组的长度求余计算出应存入的位置</p>
</li>
<li><p>判断当前位置是否为null，如果是null直接存入</p>
</li>
<li><p>如果不为null，表示有元素，则调用<code>equals</code>方法比较，相等，则不存；不相等，则存入数组</p>
<ul>
<li><p>JDK8之前，新元素存入数组，占老元素位置，老元素挂下面</p>
</li>
<li><p>JDK8之后，新元素直接挂在老元素下面</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>JDK8之后，哈希表 &#x3D; 数组 + 链表 + 红黑树</p>
<ol>
<li>当链表长度超过超过8，且数组长度&gt;&#x3D;64时，自动将链表转换成红黑树</li>
</ol>
</li>
</ul>
</li>
<li><p>如果数组快占满了，会出现什么问题？该怎么解决</p>
<ul>
<li>链表过长，导致查询性能降低</li>
<li>扩容：当数组存放数据的长度达到数组长度与默认加载因子的乘积时，便会执行扩容操作</li>
</ul>
</li>
</ol>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ol>
<li>二叉树：<ul>
<li>二叉树中，任意结点的度 &lt;&#x3D; 2</li>
<li>度：每个节点的子节点数量</li>
<li>树高：树的总层数</li>
<li>根节点：最高层的节点</li>
<li>左子节点</li>
<li>右子节点</li>
<li>左子树</li>
<li>右子树</li>
</ul>
</li>
<li>二叉查找树（二叉排序树）<ul>
<li>规则：小的存左边，大的存右边，一样的不存</li>
<li>缺陷：当数据已经是排序好的，导致查询的性能与单链表一样，查询速度变慢</li>
</ul>
</li>
<li>平衡二叉树：<ul>
<li>在满足查找二叉树的大小规则下，让树尽可能矮小，以此提高查数据的性能</li>
</ul>
</li>
<li>红黑树<ul>
<li>红黑树就是平衡二叉树</li>
<li>红黑树是一种增删改查数据性能都相对较好的结构</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础(五)——内部类、枚举、泛型</title>
    <url>/2023/09/25/Java%E5%9F%BA%E7%A1%80(%E4%BA%94)%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E6%9E%9A%E4%B8%BE%E3%80%81%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="内部类概述"><a href="#内部类概述" class="headerlink" title="内部类概述"></a>内部类概述</h2><ol>
<li><p>内部类是五大成分之一（成员变量、方法、构造方法、内部、代码块），如果一个类定义在另一个类内部，这个类就是内部类</p>
</li>
<li><p>场景：当一个类的内部，包含一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>内部类有四种形式：</p>
<ul>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ul>
</li>
</ol>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><ol>
<li><p>成员内部类就是类中的一个普通成员，类似前面我们学过的普通的成员变量、成员方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="comment">// 成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">public</span> Inner&#123;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用内部类创建对象：<code>Outer.Inner 对象名 = new Outer().new Inner();</code></p>
</li>
<li><p>成员内部类的实例方法中，访问其他成员有啥特点？</p>
<ul>
<li>可以直接访问外部类的实例成员、静态成员</li>
<li>可以拿到当前外部类的对象，格式是<code>Outer.this</code></li>
</ul>
</li>
</ol>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><ol>
<li><p>什么是静态内部类？</p>
<ul>
<li>有<code>static</code>修饰的内部类，属于外部类自己持有</li>
</ul>
</li>
<li><p>创建对象的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">class</span> Outer&#123;</span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部类名.内部类名 对象名 = new 外部类.内部类();</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br></pre></td></tr></table></figure>


</li>
<li><p>注意：可以直接访问外部类的静态成员，不可以直接访问外部类的实例成员。</p>
</li>
</ol>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ul>
<li><p>局部内部类是定义在方法中、代码块中、构造方法等执行体中（看看就好）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">C</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ol>
<li><p>匿名内部类的书写格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类或接口(参数值……)&#123;</span><br><span class="line">    类体(一般是方法重写);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;  </span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
<li><p>匿名内部类特点：</p>
<ul>
<li>匿名内部类本质就是一个子类，并会立即创建出一个子对象</li>
</ul>
</li>
<li><p>匿名内部类作用：</p>
<ul>
<li>可以更方便的创建出一个子类对象</li>
<li>匿名内部类通常作为一个参数传输给方法</li>
</ul>
</li>
</ol>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="认识枚举"><a href="#认识枚举" class="headerlink" title="认识枚举"></a>认识枚举</h2><ol>
<li><p>枚举是一种特殊的类</p>
</li>
<li><p>枚举的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    名称<span class="number">1</span>, 名称<span class="number">2</span>，……;</span><br><span class="line">    其他成员……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    X, Y, Z;</span><br><span class="line">    ……</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>枚举类中的第一行，只能写一些合法的标识符（名称），多个名称用逗号隔开。</p>
</li>
<li><p>这写名称，本质是常量，每个常量都会记住枚举类的一个对象。</p>
</li>
</ul>
</li>
<li><p>枚举的特点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    X, Y, Z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compiled from <span class="string">&quot;A.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;A&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">A</span> <span class="variable">X</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">A</span> <span class="variable">Y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">A</span> <span class="variable">Z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A[] values();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量记住的都是枚举类的一个对象。</li>
<li>枚举类的构造方法都是私有的（写不写都只能是私有的），因此，枚举类对外不能创建对象。</li>
<li>枚举类都是最终类，不可以被继承。</li>
<li>枚举类中，从第二行开始，可以定义类的其他各种成员。</li>
<li>编译器为枚举类新增了几个方法，并且枚举类都是继承：<code>java.lang.Enum</code>类的，从<code>enum</code>类也会继承到一些方法。</li>
</ul>
</li>
</ol>
<h2 id="枚举的常见应用场景"><a href="#枚举的常见应用场景" class="headerlink" title="枚举的常见应用场景"></a>枚举的常见应用场景</h2><ol>
<li>用来表示一组信息，然后作为参数进行传输。  </li>
<li>选择定义一个一个的常量来表示一组信息，并作为参数传输：参数值不受约束</li>
<li>选择定义枚举表示一组信息，并作为参数传输：代码可读性好，参数值得到了约束，对读者更友好，建议使用</li>
</ol>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="认识泛型"><a href="#认识泛型" class="headerlink" title="认识泛型"></a>认识泛型</h2><ol>
<li><p>定义类、接口、方法时，同时声明了一个或多个类型变量（如：<code>&lt;E&gt;</code>），称为泛型类、泛型接口、泛型方法，它们统称之为泛型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array</span>&lt;E&gt;&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>作用：泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力！这样可以避免强制类型转换，及其可能出现的异常。</p>
</li>
<li><p>泛型的本质：把具体的数据类型作为参数传给类型变量</p>
</li>
</ol>
<h2 id="泛型类、泛型接口"><a href="#泛型类、泛型接口" class="headerlink" title="泛型类、泛型接口"></a>泛型类、泛型接口</h2><ol>
<li><p>泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;类型变量, 类型变量, ……&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：类型变量建议使用大写的英文字母，常用的有：E、T、K、V等</p>
</li>
<li><p>泛型接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;类型变量, 类型变量, ……&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&lt;E&gt;&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="泛型方法、泛型通配符、上下限"><a href="#泛型方法、泛型通配符、上下限" class="headerlink" title="泛型方法、泛型通配符、上下限"></a>泛型方法、泛型通配符、上下限</h2><ol>
<li><p>泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符&lt;类型变量, 类型变量,……&gt; 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>通配符</p>
<ul>
<li>就是<code>?</code>，可以在”使用泛型“的时候代表一切类型；E、T、K、V是在定义泛型的时候使用。</li>
</ul>
</li>
<li><p>泛型的上下限：</p>
<ul>
<li>泛型上限：<code>? extends Car</code>，<code>?</code>能接收的必须是Car或者其子类。</li>
</ul>
</li>
</ol>
<ul>
<li>泛型下限：<code>? super Car</code>：<code>?</code>能解收的必须是Car或者其父类。</li>
</ul>
<h2 id="泛型的注意事项：擦除问题、基本数据类型问题"><a href="#泛型的注意事项：擦除问题、基本数据类型问题" class="headerlink" title="泛型的注意事项：擦除问题、基本数据类型问题"></a>泛型的注意事项：擦除问题、基本数据类型问题</h2><ol>
<li><p>泛型的擦除问题和注意实现</p>
<ul>
<li>泛型是工作在编译阶段的，一旦程序编译成class文件，class文件中就不存在泛型了，这就是泛型擦除。</li>
<li>泛型不支持基本数据类型，只能支持对象类型（引用数据类型）</li>
</ul>
</li>
</ol>
<h1 id="JDK8新特性：Lambda表达式"><a href="#JDK8新特性：Lambda表达式" class="headerlink" title="JDK8新特性：Lambda表达式"></a>JDK8新特性：Lambda表达式</h1><h2 id="认识Lambda表达式"><a href="#认识Lambda表达式" class="headerlink" title="认识Lambda表达式"></a>认识Lambda表达式</h2><ol>
<li><p>Lambda表达式是JDK8开始新增的一种语法形式，作用是用于简化匿名内部类的代码写法。</p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(被重写方法的形参列表)-&gt;&#123;</span><br><span class="line">    被重写方法的方法体代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>注意：Lambda表达式只能简化函数式接口的匿名内部类</p>
</li>
<li><p>函数式接口：</p>
<ul>
<li>有且仅有一个抽象方法的接口。</li>
<li>将来我们见到的大部分函数式接口，上面都可能会有一个<code>@FunctionalInterface</code>的注解，有该注解的接口就必定是函数式接口名。</li>
</ul>
</li>
</ol>
<h2 id="Lambda表达式的省略规则"><a href="#Lambda表达式的省略规则" class="headerlink" title="Lambda表达式的省略规则"></a>Lambda表达式的省略规则</h2><ul>
<li>参数类型可以不写。</li>
<li>如果只有一个参数，参数类型可以省略，同时<code>()</code>也可以省略</li>
<li>如果Lambda表达式中的方法体代码只有一行代码，可以省略大括号不写，同时要省略分号！此时，如果这行代码是return语句，也必须去掉return不写</li>
</ul>
<h1 id="JDK8新特性：方法引用"><a href="#JDK8新特性：方法引用" class="headerlink" title="JDK8新特性：方法引用"></a>JDK8新特性：方法引用</h1><h2 id="静态方法的引用"><a href="#静态方法的引用" class="headerlink" title="静态方法的引用"></a>静态方法的引用</h2><ol>
<li>静态方法的引用：<code>类名::静态方法</code></li>
<li>使用场景：如果某个Lambda表达式里只是调用一个静态方法，并且前后参数的形式一致，就可以使用静态方法引用。</li>
</ol>
<h2 id="实例方法的引用"><a href="#实例方法的引用" class="headerlink" title="实例方法的引用"></a>实例方法的引用</h2><ol>
<li>实例方法的引用：<code>类名::实例方法</code></li>
<li>使用场景：如果某个Lambda表达式里只是调用一个实例方法，并且前后参数的形式一致，就可以使用实例方法引用。</li>
</ol>
<h2 id="特定类型方法的引用"><a href="#特定类型方法的引用" class="headerlink" title="特定类型方法的引用"></a>特定类型方法的引用</h2><ol>
<li>特定类型方法的引用：<code>类型::方法</code></li>
<li>使用场景：如果某个Lambda表达式里只是调用一个实例方法，并且前面参数列表中的第一个参数是作为作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用指定类型的方法引用。</li>
</ol>
<h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><ol>
<li>构造器引用：<code>类名::new</code></li>
<li>使用场景：如果某个lambda表达式里只是在创建对象，并且前后参数情况一致，就可以使用构造器引用。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础(二)——流程控制</title>
    <url>/2023/09/09/Java%E5%9F%BA%E7%A1%80(%E4%BA%8C)%E2%80%94%E2%80%94%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><ol>
<li><p>if分支：可以根据条件，选择执行某段程序</p>
</li>
<li><p>if分支的三种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种语法</span></span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    语句;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种语法</span></span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：如果if语句的{}中只有一行代码的情况下，{}可以不写</p>
</li>
</ol>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><ol>
<li><p>使用switch时有哪些注意事项？</p>
<ul>
<li>表达式类型只能是byte、short、int、char，JDK5开始支持枚举，JDK7开始支持String、不支持double、float、long。</li>
<li>case给出的值不允许重复，且只能是字面量，不能是变量。</li>
<li>正常使用switch的时候，不要忘记写break，否则会出现穿透现象</li>
</ul>
</li>
<li><p>switch穿透性能解决什么问题？</p>
<p>存在多个case分支的代码时一样时，可以把代码写道一个case块，其他case块通过穿透性能，穿透到case块即可，这样可以简化代码。</p>
</li>
</ol>
<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ol>
<li><p>for循环格式和执行流程是什么样的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(变量赋值; 循环条件; 变量增值)&#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for循环的常见应用场景？</p>
<p>减少代码的重复编写，灵活的控制程序的执行</p>
</li>
</ol>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><ol>
<li><p>while循环的格式和执行流程是怎么样的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">    迭代语句;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">3</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while和for有什么区别？什么时候使用for，什么时候使用while？</p>
<ul>
<li>功能上是完全一样的，for能解决的while也能解决，反之亦然。</li>
<li>使用规范：知道循环几次使用for；不知道循环几次建议使用while。</li>
</ul>
</li>
</ol>
<h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h2><ol>
<li><p>do-while循环的格式和执行流程是怎么样的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">    迭代语句;</span><br><span class="line">&#125; <span class="keyword">while</span>(循环条件)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    i++;</span><br><span class="line">&#125; w <span class="title function_">hile</span><span class="params">(循环条件)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>do-while循环的特点：先执行后判断</p>
</li>
</ol>
<h2 id="三种循环的区别小结"><a href="#三种循环的区别小结" class="headerlink" title="三种循环的区别小结"></a>三种循环的区别小结</h2><ul>
<li>for循环和while循环（先判断后执行），do-while循环（先执行后判断）</li>
<li>for循环和while循环的执行流程是一模一样的，功能上无区别，for能解决的while也能解决，反之亦然。</li>
<li>使用规范：知道循环几次使用for；不知道循环几次建议使用while。</li>
<li>其他区别：for循环中，控制循环的变量只在循环中使用。while循环中，控制循环的变量在循环后还可以继续使用。</li>
</ul>
<h2 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h2><ul>
<li><p>可以一直执行下去的一种循环，如果没有干预不会停下来。</p>
</li>
<li><p>写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用场景：服务器程序</p>
</li>
</ul>
<h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><ul>
<li>循环中又包含循环 </li>
<li>外部循环每循环一次，内部循环会完全执行完一轮。</li>
</ul>
<h1 id="跳转关键字：break、continue"><a href="#跳转关键字：break、continue" class="headerlink" title="跳转关键字：break、continue"></a>跳转关键字：break、continue</h1><ul>
<li>break：跳出并结束当前所在循环的执行。</li>
<li>continue：用于跳出当前循环的当次执行，直接进入循环的下一次执行。</li>
</ul>
<h1 id="生成随机数：Random"><a href="#生成随机数：Random" class="headerlink" title="生成随机数：Random"></a>生成随机数：Random</h1><ul>
<li>作用：生成随机数。</li>
<li>得到0-9的随机数的实现步骤：<ol>
<li>导包：告诉程序去JDK的哪个包中找Random，<code>import java.util.Random;</code></li>
<li>创建随机数对象：<code>Random r = new Random();</code></li>
<li>调用随机数的功能获取随机数：<code>int num = r.nextInt(10);</code></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础(三)——数组、方法</title>
    <url>/2023/09/22/Java%E5%9F%BA%E7%A1%80(%E4%B8%89)%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E3%80%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h1><ul>
<li>数组就是一个容器，用来存储一批同种类型的数据</li>
</ul>
<h1 id="数组的定义和访问"><a href="#数组的定义和访问" class="headerlink" title="数组的定义和访问"></a>数组的定义和访问</h1><h2 id="静态初始化数组"><a href="#静态初始化数组" class="headerlink" title="静态初始化数组"></a>静态初始化数组</h2><ol>
<li><p>数组的静态初始化的写法和特点什么样的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3</span>,……&#125;;</span><br><span class="line"><span class="type">int</span>[] ages = &#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>, <span class="number">68</span>&#125;;</span><br><span class="line"><span class="type">double</span>[] scores = &#123;<span class="number">89.9</span>, <span class="number">79.8</span>, <span class="number">69.1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完整格式</span></span><br><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3</span>,……&#125;;</span><br><span class="line"><span class="type">int</span>[] ages = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>, <span class="number">68</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：</p>
<ul>
<li>什么类型的数组必须存放什么类型的数据。</li>
<li>“数据类型[] 数组名”  也可以写成  “数据类型 数组名[]”</li>
<li>数组是引用数据类型，数组变量名中存储的是数组在内存中的地址信息</li>
</ul>
</li>
<li><p>数组的访问</p>
<ul>
<li>访问数组的元素：<code>数组名称[索引]</code></li>
<li>访问数组的长度：<code>数组名称.length</code></li>
<li>数组的最大索引：<code>数组名.length - 1</code></li>
<li>如果访问数组时，使用的索引超过了数组长度执行程序时会出bug，出现一个索引越界的异常提示。</li>
</ul>
</li>
<li><p>数组的遍历</p>
<ul>
<li><p>遍历：一个一个的访问一遍容器中的数据。</p>
</li>
<li><p>如何遍历数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] ages = &#123;<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ages.length; i++)&#123;</span><br><span class="line">    System.out.println(ages[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="动态初始化数组"><a href="#动态初始化数组" class="headerlink" title="动态初始化数组"></a>动态初始化数组</h2><ol>
<li><p>动态初始化数组的写法时什么样的？有什么特点?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[长度];</span><br><span class="line"><span class="type">int</span>[] ages = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态初始化数组后元素的默认值：</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte、short、char、int、 long</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">float、double</td>
<td align="center">0.0</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">类、接口、数组、String</td>
<td align="center">null</td>
</tr>
</tbody></table>
</li>
<li><p>两种数组定义的方法各自适合什么业务场景？</p>
<ul>
<li>动态初始化：适合开始不确定具体元素值，只知道元素个数的业务场景</li>
<li>静态初始化：适合一开始就知道要存入那些元素值的业务场景</li>
</ul>
</li>
</ol>
<h1 id="数组在计算机中的执行原理"><a href="#数组在计算机中的执行原理" class="headerlink" title="数组在计算机中的执行原理"></a>数组在计算机中的执行原理</h1><ol>
<li>运行一个Java程序，主要看JVM中包含的哪几部分内存区域？<ul>
<li>方法区：字节码文件先加载到这里</li>
<li>栈内存：方法运行时所进入的内存，变量也是在这里</li>
<li>堆内存：new出来的东西会在这块内存中开辟空间并产生地址</li>
</ul>
</li>
<li><code>int a=20;</code>和<code>int[] arr = new int[3];</code>这两行代码的执行原理？<ul>
<li>a是变量，直接放在栈中，a变量中存储的数据就是20这个值。</li>
<li><code>new int[3]</code>是创建一个数组对象，会在堆内存中开辟区域存储3个整数。</li>
<li>arr是变量，在栈中，arr中存储的数组对象在堆内存中的地址值。</li>
</ul>
</li>
<li>多个数组变量，指向同一个数组对象的原因是什么？需要注意什么？<ul>
<li>多个数组变量中存储的是同一个数组对象的地址。</li>
<li>多个变量修改的都是同一数组对象中的数据。</li>
</ul>
</li>
<li>如果某个数组变量中存储的null，代表什么意思？需要注意什么？<ul>
<li>代表这个数组变量没有指向数组对象。</li>
<li>可以输出这个变量，但不能用这个数组变量去访问数据或者数组长度。会报空指针异常：NullPointerException。</li>
</ul>
</li>
</ol>
<h1 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h1><ol>
<li><p>方法：方法是一种语法结构，它可以把一段代码封装成一个功能，以便重复调用，提高开发效率，使程序逻辑更清晰。</p>
</li>
<li><p>方法的完整结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">    方法体代码(需要执行的功能代码);</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果方法不需要接收数据处理，不需要返回数据，应该怎么办，要注意什么？</p>
<ul>
<li>方法不需要接收数据，则形参列表可以不写；方法不需要返回值，则申明返回值类型为void。</li>
<li>方法没有申明返回值类型（void），内部不能使用return返回数据。</li>
<li>方法如果没有形参列表，调用的时候则不能传入数值，否则报错。</li>
</ul>
</li>
<li><p>方法使用时的常见问题</p>
<ul>
<li>方法在类中的位置放前放后无所谓，但一个方法不能定义在另一个方法里面。</li>
<li>方法的返回值类型写void时，方法内不能使用return返回数据。如果方法的返回值类型写了具体类型，方法内部则必须使用return返回对应类型的数据。</li>
<li>return语句的下面，不能编写代码，属于无效代码，执行不到这儿。</li>
<li>方法不调用就不会执行，调用方法时，传给方法的数据，必须严格匹配方法的参数情况。</li>
<li>调用有返回值的方法，有3种方法：<ol>
<li>可以定义变量接收结果</li>
<li>直接输出</li>
<li>直接调用</li>
</ol>
</li>
<li>调用无返回值的方法：直接调用</li>
</ul>
</li>
</ol>
<h1 id="方法在计算机中的执行原理"><a href="#方法在计算机中的执行原理" class="headerlink" title="方法在计算机中的执行原理"></a>方法在计算机中的执行原理</h1><ol>
<li>方法的运行区域：栈内存</li>
<li>栈有什么特点？方法为什么要在栈中运行自己？<ul>
<li>先进后出</li>
<li>保证一个方法调用完另一个方法后，可以回来</li>
</ul>
</li>
</ol>
<h1 id="Java的参数传递"><a href="#Java的参数传递" class="headerlink" title="Java的参数传递"></a>Java的参数传递</h1><ol>
<li>Java的参数传递机制是什么样的？<ul>
<li>值传递。传输的是实参存储的值的副本</li>
<li>实参：在方法内部定义的变量</li>
<li>形参：以方法为例，就是方法定义时的变量</li>
</ul>
</li>
<li>基本类型和引用类型的参数在传递的时候有什么不同？<ul>
<li>都是值传递</li>
<li>基本数据类型的参数传输存储的数据值</li>
<li>引用类型的参数传递存储的地址值</li>
</ul>
</li>
</ol>
<h1 id="方法重载-amp-return关键字"><a href="#方法重载-amp-return关键字" class="headerlink" title="方法重载 &amp; return关键字"></a>方法重载 &amp; return关键字</h1><ol>
<li><p>什么是方法重载？</p>
<p>一个类中，多个方法的名称相同，但他们形参列表不同</p>
</li>
<li><p>方法重载需要注意什么?</p>
<ul>
<li>一个类中，只要一些方法的名称相同、形参列表不同，那么它们就是方法的重载了，其他的都不管（如：修饰符，返回值类型是否一样都无所谓）。</li>
<li>形式列表不同指的是：形参的个数、类型、顺序不同，不关心形参的名称。</li>
</ul>
</li>
<li><p>方法重载有啥应用场景？</p>
<p>开发中我们经常需要为处理一类业务，提供多种解决方案，此时用方法重载来设计是很专业的。</p>
</li>
<li><p>在无返回值的方法中。如果要直接跳出并结束当前方法的执行，怎么解决？</p>
<ul>
<li>return;跳出并立即结束所在方法的执行</li>
<li>break;跳出并结束当前所在循环的执行</li>
<li>continue;结束当前所在循环的当次继续，进入下一次执行</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础(四)——面向对象</title>
    <url>/2023/09/24/Java%E5%9F%BA%E7%A1%80(%E5%9B%9B)%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="认识面向对象编程"><a href="#认识面向对象编程" class="headerlink" title="认识面向对象编程"></a>认识面向对象编程</h1><ol>
<li><p>面向对象编程的优点： </p>
<ul>
<li>凡是找对象的编程套路，更加符合人类思维习惯，编程也会更直观</li>
</ul>
</li>
<li><p>对象是啥？如何得到？</p>
<ul>
<li><p>对象就是一种特殊的数据结构。</p>
</li>
<li><p>对象是用类new出来的，有了类就可以创建出对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名&#123;</span><br><span class="line">    <span class="number">1.</span>变量，用来说明对象可以处理什么数据</span><br><span class="line">    <span class="number">2.</span>方法，描述对象有什么功能，也就是可以对数据进行什么样的处理</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>类名 对象名 = new 类名();</code></p>
</li>
</ul>
</li>
<li><p>面向对象编程这种套路是咋回事？</p>
<ul>
<li>祖师爷（詹姆斯·高斯林 ）认为万物皆对象，谁的数据谁处理</li>
</ul>
</li>
<li><p>面向对象编程的三大特性：继承、封装、多态</p>
</li>
</ol>
<h1 id="对象在计算机中的执行原理"><a href="#对象在计算机中的执行原理" class="headerlink" title="对象在计算机中的执行原理"></a>对象在计算机中的执行原理</h1><ol>
<li>对象在计算机中的执行原理是怎么回事？<ul>
<li><code>Student s = new Student();</code></li>
<li>每次创建对象，就是在堆内存中开辟一块内存区域代表一个学生对象。</li>
<li>对象变量里面记住的是学生对象的地址。</li>
</ul>
</li>
<li>如何识别引用类型的变量？<ul>
<li>变量中存储的是地址就是引用类型的变量</li>
</ul>
</li>
</ol>
<h1 id="类和对象的一些注意事项"><a href="#类和对象的一些注意事项" class="headerlink" title="类和对象的一些注意事项"></a>类和对象的一些注意事项</h1><ol>
<li><p>类名建议用英文单词，首字母大写，满足驼峰模式，且要有意义，比如：Student、Car……</p>
</li>
<li><p>类中定义的变量也称为成员变量（对象的属性），类中定义的方法也称为成员方法（对象的行为）。</p>
</li>
<li><p>成员变量本身存在默认值。</p>
</li>
<li><p>一个代码文件中，可以写多个class类，但只能一个用public修饰，且public修饰的类名必须称为代码文件名。</p>
</li>
<li><p>对象与对象之间的数据不会相互影响，但多个变量指向同一个对象时就会相互影响了。</p>
</li>
<li><p>如果某个对象没有变量引用它，则该对象无法被操作，该对象会变为所谓的垃圾对象。</p>
<p>Java存在自动垃圾回收机制，会自动清除掉垃圾对象</p>
</li>
</ol>
<h1 id="this、构造方法"><a href="#this、构造方法" class="headerlink" title="this、构造方法"></a>this、构造方法</h1><ol>
<li><p>this关键字时什么？</p>
<ul>
<li>this就是一个变量，可以用在方法里，用来拿到当前对象；哪个对象调用方法，this就指向哪个对象，也就是拿到哪个对象。</li>
</ul>
</li>
<li><p>this关键字在实际开发中常用来干啥？</p>
<ul>
<li>用来解决对象的成员变量与方法内部变量的名称一样时，导致访问冲突问题。</li>
</ul>
</li>
<li><p>构造方法语法：与类名相同，没有方法类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>()&#123;</span><br><span class="line">    <span class="comment">/*构造方法*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方法用途：</p>
<ul>
<li>对象创建时，我们可以指定对象去调用哪个构造方法执行。</li>
<li>构造方法常用于完成对象初始化（给成员变量传值）</li>
</ul>
</li>
<li><p>构造方法在使用时的注意事项：</p>
<ul>
<li>类在设计时，如果不写构造方法Java会为类自动生成一个无参构造方法</li>
<li>一旦定义了有参构造方法，Java就不会自动生成无参构造方法了，此时建议自己手写一个无参构造方法</li>
</ul>
</li>
</ol>
<h1 id="封装、实体JavaBean"><a href="#封装、实体JavaBean" class="headerlink" title="封装、实体JavaBean"></a>封装、实体JavaBean</h1><ol>
<li>什么是封装？<ul>
<li>封装就是用类设计对象处理某一个事物的数据时，应该把要处理的数据，以及处理这些数据的方法。设计到一个对象中去。</li>
</ul>
</li>
<li>封装的设计规范是什么样的？<ul>
<li>合理隐藏，合理暴露</li>
</ul>
</li>
<li>代码层如何控制对象的成员公开或隐藏？<ul>
<li>公开成员，可以使用public(公开)进行修饰。</li>
<li>隐藏成员，使用private(私有、隐藏)进行修饰。</li>
</ul>
</li>
<li>什么是实体类？有什么特点？<ul>
<li>成员变量必须私有，且要为他们提供get、set方法；必须有无参数构造方法</li>
<li>仅仅是一个用来保存数据的Java类，可以用它创建对象，保存某个事物的数据</li>
</ul>
</li>
<li>实体类的应用场景：<ul>
<li>实体类对应的是软件开发里现在比较流行的开发方式，数据和数据业务处理相分离</li>
</ul>
</li>
</ol>
<h1 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h1><table>
<thead>
<tr>
<th align="center">区别</th>
<th align="center">成员变量</th>
<th align="center">局部变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类中位置不同</td>
<td align="center">类中，方法外</td>
<td align="center">常见于方法中</td>
</tr>
<tr>
<td align="center">初始化值不同</td>
<td align="center">有默认值，不需要初始化赋值</td>
<td align="center">没有默认值，使用之前必须完成赋值</td>
</tr>
<tr>
<td align="center">内存位置不同</td>
<td align="center">堆内存</td>
<td align="center">栈内存</td>
</tr>
<tr>
<td align="center">作用域不同</td>
<td align="center">整个对象</td>
<td align="center">在所属的大括号中</td>
</tr>
<tr>
<td align="center">作用周期不同</td>
<td align="center">与对象相同</td>
<td align="center">随着方法调用而出现，随方法结束而结束</td>
</tr>
</tbody></table>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ol>
<li>static叫静态，可以修饰成员变量、成员方法。</li>
<li>成员变量按照有无<code>static</code>修饰，分为两类：<ul>
<li>类变量：<ul>
<li>有<code>static</code>修饰，属于类，在计算机中只有一份，<strong>会被类的全部对象共享</strong></li>
<li>应用场景：如果某一份数据只需要一份，且希望能够被共享（访问、修改），则建议使用类变量来记录</li>
</ul>
</li>
<li>实例变量（对象的变量）：<ul>
<li>无<code>static</code>修饰，<strong>每个对象都有一份</strong></li>
<li>应用场景：每个对象都要有一份，数据各不同</li>
</ul>
</li>
</ul>
</li>
<li>成员方法按照有无<code>static</code>修饰，分为两类：<ul>
<li>类方法（静态方法）：<ul>
<li>属于类，可以直接用类名访问，也可以对象访问</li>
<li>应用场景：可以用来设计工具类</li>
</ul>
</li>
<li>实例方法：<ul>
<li>属于对象，只能使用对象访问</li>
</ul>
</li>
<li>工具类<ul>
<li>工具类中的方法都是类方法，每个类方法都是用来完成一个功能的</li>
<li>工具类提高了代码的复用性；调用方法，提高了开发效率</li>
<li>工具类之所以使用类方法实现，是因为这样可以不用创建对象而浪费内存</li>
<li>工具类不需要创建对象，建议将工具类的构造方法私有化</li>
</ul>
</li>
</ul>
</li>
<li>注意事项：<ul>
<li>类方法可以直接访问类的成员，不可以直接访问实例成员</li>
<li>实例方法既可以直接访问类成员，也可以直接访问实例成员</li>
<li>实例方法中可以出现this关键字，类方法中不可以出现this关键字</li>
</ul>
</li>
</ol>
<h1 id="static应用知识"><a href="#static应用知识" class="headerlink" title="static应用知识"></a>static应用知识</h1><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ol>
<li>代码块概述<ul>
<li>代码块是类的5大成分之一（成员变量、构造方法、方法、代码块、内部类）</li>
</ul>
</li>
<li>代码块分为两种：<ul>
<li>静态代码块：<ul>
<li>格式：<code>static&#123;&#125;</code></li>
<li>特点：类加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次</li>
<li>作用：完成类的初始化，例如：对类变量的初始化赋值</li>
</ul>
</li>
<li>实例代码块：<ul>
<li>格式：<code>&#123;&#125;</code></li>
<li>特点：每次创建对象时，执行实例代码块，并在构造方法前执行</li>
<li>作用：和构造方法一样，都是用来完成对象的初始化，例如：对实例变量进行初始化赋值</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><ol>
<li><p>什么是设计模式（Design pattern）？</p>
<ul>
<li>一个问题通常有很多种解法，其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为设计模式。</li>
<li>设计模式有20多种，对应20多种软件开发中会遇到的问题。</li>
</ul>
</li>
<li><p>单例设计模式：确保一个类只有一个对象。</p>
</li>
<li><p>写法：</p>
<ul>
<li>把类的构造方法私有</li>
<li>定义一个类变量记住类的对象</li>
<li>定义一个类方法，返回对象</li>
</ul>
</li>
<li><p>单例的应用场景：任务管理器对象、获取运行时对象</p>
</li>
<li><p>单例设计模式的实现方式很多，如：饿汉式单例、懒汉式单例、……</p>
</li>
<li><p>饿汉式单例设计模式：拿对象时，对象早就创建好了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getObject</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>懒汉式单例设计模式：拿对象时，才开始创建对象（延迟加载对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="literal">null</span>)&#123;</span><br><span class="line">            b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="认识继承"><a href="#认识继承" class="headerlink" title="认识继承"></a>认识继承</h2><ol>
<li><p>什么是继承？继承后有什么有啥特点？</p>
<ul>
<li><p>继承就是用<code>extends</code>关键字，让一个类和另一个类建立起一种父子关系</p>
</li>
<li><p>子类可以继承父类非私有成员</p>
</li>
</ul>
</li>
<li><p>带继承关系的类，Java会怎创建它的对象？对象创建出来后，可以直接访问哪些成员？</p>
<ul>
<li><p>带继承关系的类，Java会用类和其父类，这么多张设计图来一起创建类的对象。</p>
</li>
<li><p>对象能直接访问什么成员，是由子父类这么多张设计图共同决定，这么多张设计图对外暴露了什么成员，对象就可以访问什么成员。</p>
</li>
</ul>
</li>
<li><p>继承的好处：减少重复代码的编写，提高了代码的复用性。</p>
</li>
<li><p>权限修饰符：就是用来限制类中的成员（成员变量、成员方法、构造方法、代码块……）能够被访问的范围</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">同一个类</th>
<th align="center">同一个包</th>
<th align="center">子类</th>
<th align="center">任意包</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
</li>
<li><p>继承相关的两个注意事项：</p>
<ul>
<li><p>Java是单继承：一个类只能继承一个直接父类；Java中的类不支持多继承，但是支持多层继承。</p>
</li>
<li><p>Object类是Java中的所有类的祖宗。</p>
</li>
</ul>
</li>
</ol>
<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><ol>
<li><p>方法重写：子类写了一个方法名称、形参列表与父类某个方法一样的方法去覆盖父类的该方法。</p>
</li>
<li><p>重写方法的注意事项：</p>
<ul>
<li><p>建议加上：<code>@Override</code>注解，可以校验重写是否正确，同样可读性好。</p>
</li>
<li><p>子类重写父类方法时，访问权限必须大于或等于父类被重写的方法的权限。</p>
</li>
<li><p>重写的方法返回值类型，必须与被重写方法的返回值类型一样，或者范围更小。</p>
</li>
<li><p>私有方法、静态方法不能被重写。</p>
</li>
</ul>
</li>
<li><p>方法重写应用场景：当子类觉得父类的方法不好用，或者不满足自己需求时，就可以用方法重写</p>
</li>
</ol>
<h2 id="子类访问其他成员的规则、子类构造方法的特点"><a href="#子类访问其他成员的规则、子类构造方法的特点" class="headerlink" title="子类访问其他成员的规则、子类构造方法的特点"></a>子类访问其他成员的规则、子类构造方法的特点</h2><ol>
<li><p>在子类方法中访问其他成员（成员变量、成员方法），是依照就近原则的。</p>
<ul>
<li><p>先子类局部范围找</p>
</li>
<li><p>然后子类成员范围找</p>
</li>
<li><p>然后父类成员范围找，如果都没有找到就会报错</p>
</li>
</ul>
</li>
<li><p>如果子父类中，出现了重名的成员，会优先使用子类，那么该如何使用在子类中使用父类的成员呢？</p>
<ul>
<li>可以通过<code>super</code>关键字，指定访问父类的成员：<code>super.父类成员变量/父类成员方法;</code></li>
</ul>
</li>
<li><p>子类构造方法的特点：子类的全部构造方法，都会先调用父类的构造方法，再执行自己。</p>
</li>
<li><p>子类构造方法是如何实现调用父类构造方法的：</p>
<ul>
<li><p>默认情况下，子类全部构造方法的第一行代码都是<code>super();</code>（写不写都存在），它会调用父类的无参构造方法。</p>
</li>
<li><p>如果父类没有无参构造方法，则我们必须在子类构造方法的第一行手写<code>super(……);</code>，指定去调用父类的有参构造方法</p>
</li>
</ul>
</li>
<li><p><code>this(……)</code>：在构造方法中调用本类的其他构造方法</p>
</li>
<li><p>注意：使用<code>this()</code>和<code>super()</code>时必须放在构造方法的第一行</p>
</li>
</ol>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="认识多态"><a href="#认识多态" class="headerlink" title="认识多态"></a>认识多态</h2><ol>
<li><p>多态：多态是在继承&#x2F;实现情况下的一种现象，表现为：对象多态、行为多态。</p>
</li>
<li><p>多态的具体代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student类和Teacher类均为People类的子类</span></span><br><span class="line"></span><br><span class="line"><span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">p1.run();</span><br><span class="line"></span><br><span class="line"><span class="type">People</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">p2.run();</span><br></pre></td></tr></table></figure>


</li>
<li><p>多态的前提：有继承&#x2F;实现关系；存在父类引用子类对象；存在方法重写。</p>
</li>
<li><p>注意事项：多态是对象、行为多态，Java中的属性（成员变量）不谈多态。</p>
</li>
</ol>
<h2 id="使用多态的好处"><a href="#使用多态的好处" class="headerlink" title="使用多态的好处"></a>使用多态的好处</h2><ol>
<li>使用代码有什么好处？存在什么问题？<ul>
<li>好处：可以解耦合，扩展性更强；使用父类类型的变量作为方法的形参时，可以接收一切子类对象。</li>
<li>问题：多态下不能直接调用子类的独有方法</li>
</ul>
</li>
</ol>
<h2 id="多态下的类型转换问题"><a href="#多态下的类型转换问题" class="headerlink" title="多态下的类型转换问题"></a>多态下的类型转换问题</h2><ol>
<li><p>类型转换有几种类型？能解决什么问题？</p>
<ul>
<li><p>自动类型转换、强制类型转换</p>
</li>
<li><p>可以把对象转换成其真正的类型，从而解决了多态下不能调用子类独有方法的问题</p>
</li>
</ul>
</li>
<li><p>强制类型转换需要注意什么？</p>
<ul>
<li><p>存在继承&#x2F;实现时，就可以进行强制类型转换，编译阶段不会报错。</p>
</li>
<li><p>但是，运行时，如果发现对象的真实类型与强转后的类型不同会报错（<em><strong>ClassCastException</strong></em>）</p>
</li>
</ul>
</li>
<li><p>强制转换类型前？Java建议我们做什么？</p>
<ul>
<li>使用<code>instanceof</code>判断当前对象的真实类型：<code>对象 instanceof 类型</code></li>
</ul>
</li>
</ol>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h2 id="认识final"><a href="#认识final" class="headerlink" title="认识final"></a>认识final</h2><ol>
<li>final关键字是最终的意思，可以修饰（类、方法、变量）</li>
<li>修饰类：该类被称为最终类，特点是不能被继承了。</li>
<li>修饰方法：该方法被称为最终方法，特点是不能被重写了。</li>
<li>修饰变量：该变量只能被赋值一次。</li>
<li>final修饰变量的注意：<ul>
<li>final修饰基本类型的变量，变量存储的数据不能被改变。</li>
<li>final修饰引用类型的变量，变量存储的地址不能被改变，但地址所指向对象的内容是可以被改变的。</li>
</ul>
</li>
</ol>
<h2 id="补充知识：常量详解"><a href="#补充知识：常量详解" class="headerlink" title="补充知识：常量详解"></a>补充知识：常量详解</h2><ol>
<li><p>使用了<code>static final</code>修饰的成员变量就被称为常量</p>
</li>
<li><p>作用：通常用于记录系统的配置信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constant</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;伽里敦大学&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：常量名的命名规范：建议大家使用大写英文单词，多个单词使用下划线连接起来。</p>
</li>
<li><p>使用常量记录系统配置信息的优势、执行原理</p>
<ul>
<li>代码可读性更好，可维护性也更好。</li>
<li>程序编译后，常量会被“宏替换”：出现常量的地方全部会被替换成其记住的字面量，这样可以保证使用常量和直接用字面量的性能是一样的。</li>
</ul>
</li>
</ol>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h2 id="认识抽象类"><a href="#认识抽象类" class="headerlink" title="认识抽象类"></a>认识抽象类</h2><ol>
<li><p>抽象类、抽象方法是什么样的？</p>
<ul>
<li>都是用<code>abstract</code>修饰的；抽象方法只有方法签名，不能写方法体。</li>
</ul>
</li>
<li><p>抽象类有哪些注意事项和特点？</p>
<ul>
<li><p>抽象类中可以不写抽象方法，但抽象方法的类一定是抽象类。</p>
</li>
<li><p>类有的成员（成员变量、方法、构造器）抽象类都具备。</p>
</li>
<li><p>抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现。</p>
</li>
<li><p>一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象方法。</p>
</li>
</ul>
</li>
<li><p>抽象类的应用场景和好处是什么？</p>
<ul>
<li>应用场景：父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现。</li>
<li>好处：我们抽出这样的抽象类，就是为了更好的支持多态。</li>
</ul>
</li>
</ol>
<h2 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h2><ol>
<li><p>模板方法设计模式解决了什么问题？</p>
<ul>
<li>解决方法中存在重复代码的问题</li>
</ul>
</li>
<li><p>模板设计方法应该怎么写？</p>
<ol>
<li><p>定义一个抽象类。</p>
</li>
<li><p>在里面定义2个方法：</p>
<ul>
<li><p>一个是模板方法：把相同代码放里面去。</p>
</li>
<li><p>一个是抽象方法：具体实现交给子类。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>建议使用<code>final</code>关键字修饰模板方法</p>
<ul>
<li>模板方法是给对象直接使用的，不能被子类重写。</li>
<li>一旦子类重写了模板方法，模板方法就失效了</li>
</ul>
</li>
</ol>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="认识接口"><a href="#认识接口" class="headerlink" title="认识接口"></a>认识接口</h2><ol>
<li><p>Java提供了一个关键字<code>interface</code>，用这个关键字我们可以定义出一个特殊的结构：<em>接口</em>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">    <span class="comment">//成员变量（常量）</span></span><br><span class="line">    <span class="comment">//成员方法（抽象方法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：接口不能创建对象</p>
</li>
<li><p>接口是用来被类实现的（<code>implements</code>）的，实现接口的类称为实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名 implements 接口<span class="number">1</span>, 接口<span class="number">2</span>，……&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类可以实现多个接口，实现类实现多个接口，必须重写完全部接口的全部抽象方法，否则实现类需要定义成抽象类。</p>
</li>
</ol>
<h2 id="使用接口的好处"><a href="#使用接口的好处" class="headerlink" title="使用接口的好处"></a>使用接口的好处</h2><ol>
<li>弥补了类单继承的不足，一个类可以同时实现多个接口</li>
<li>别人通过类实现的接口，就可以显性的知道类实现的功能</li>
<li>让程序可以面向接口编程，这样程序员就可以灵活方便的切换各种业务实现</li>
</ol>
<h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2><ol>
<li><p>JDK8开始，在接口中新增了哪些方法？</p>
<ul>
<li><p>默认方法：使用<code>default</code>修饰，使用实现类的对象调用</p>
</li>
<li><p>静态方法：<code>static</code>修饰，必须使用当前接口名调用</p>
</li>
<li><p>私有方法：<code>private</code>修饰，jdk9开始才有的，只能在接口内部被调用</p>
</li>
<li><p>他们都会默认被<code>public</code>修饰</p>
</li>
</ul>
</li>
<li><p>JDK8开始，接口为什么要新增这些方法？</p>
<ul>
<li>增强了接口的能力，更便于项目的扩展和维护</li>
</ul>
</li>
<li><p>接口的多继承：一个接口可以同时继承多个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span>&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口是多继承的</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span>, B, A&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口多继承的作用：便于实现类去实现</p>
</li>
<li><p>接口其他注意事项：</p>
<ul>
<li>一个接口继承多个接口，如果多个接口中存在方法签名冲突，则此时不支持多继承</li>
<li>一个类实现多个接口，如果多个继承中存在方法签名冲突，则此时不支持多实现</li>
<li>一个类继承了父类，又同时实现了接口，父类中和接口中有同名的默认方法，实现类会优先用父类的</li>
<li>一个类实现了多个接口，多个接口中存在同名的默认方法，可以不冲突，这个类重写方法即可</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础(一)——基本数据类型</title>
    <url>/2023/07/13/Python%E5%9F%BA%E7%A1%80(%E4%B8%80)%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="初识Python"><a href="#初识Python" class="headerlink" title="初识Python"></a>初识Python</h1><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>1989年，Guidio van Rossum吉多·范罗苏姆决心开发一个新的解释程序（Python雏形）</p>
<p>1991年，第一个Python解释器诞生，Pyhton名字来自于吉多·范罗苏姆喜欢的电视：<em>Monty Python‘s Flying Circus</em></p>
<h2 id="适用面"><a href="#适用面" class="headerlink" title="适用面"></a>适用面</h2><table>
<thead>
<tr>
<th>人群</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>IT从业者</td>
<td>自动化脚本（运维开发、测试工具等）</td>
</tr>
<tr>
<td>普通白领</td>
<td>自动化办公</td>
</tr>
<tr>
<td>后端开发</td>
<td>WEB应用程序</td>
</tr>
<tr>
<td>科学家基于</td>
<td>基于Python完成数据计算（生物、化学、物理）</td>
</tr>
<tr>
<td>人工智能&#x2F;机器学习</td>
<td>基于Python开发AI程序</td>
</tr>
<tr>
<td>大数据开发</td>
<td>基于Python完成大数据任务开发（Spark、Flink）</td>
</tr>
</tbody></table>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>Python解释器环境内，执行单行代码</li>
<li>使用Python解释器执行，执行Python代码文件</li>
<li>使用第三方IDE(集成开发工具)，如PyCharm软件、开发Python程序</li>
</ul>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>字面量：在代码中，被写下来的固定值，成为字面量</p>
<p>常用的值的类型：Python中常用的6种值（数据）的类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>数字（Number）</td>
<td>整数（int）、浮点数（float）、复数（complex）、布尔（bool）</td>
<td></td>
</tr>
<tr>
<td>字符串（Strng）</td>
<td>描述文本的一种数据类型</td>
<td>字符串由任意数量的字符组成</td>
</tr>
<tr>
<td>列表（List）</td>
<td>有序的可变序列</td>
<td>Python中使用在频繁的数据类型，可有序记录一堆数据</td>
</tr>
<tr>
<td>元组（Tuple）</td>
<td>有序的不可变序列</td>
<td>可有序记录一堆不可变的Python数据集合</td>
</tr>
<tr>
<td>集合（Set）</td>
<td>无序不重合集合</td>
<td>可无序记录一堆不重复的Python数据集合</td>
</tr>
<tr>
<td>字典（Dictionary）</td>
<td>无序Key-Value集合</td>
<td>可无序纪律一堆Key-Value型的Python数据集合</td>
</tr>
</tbody></table>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是注释1，只能单行</span></span><br><span class="line"><span class="string">&quot;&quot;&quot; 这是注释2，可以多行注释 &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量就是在程序运行时，记录数据的，变量的值可以改变</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>目前入门阶段，主要接触三类数据类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>字符串类型</td>
<td>用引号引起来的数据都是字符串</td>
</tr>
<tr>
<td>int</td>
<td>整形（有符号）</td>
<td>数字类型，存放整数</td>
</tr>
<tr>
<td>float</td>
<td>浮点型（有符号）</td>
<td>数字类型，存放小数</td>
</tr>
</tbody></table>
<p>可以使用type()语句查看数据类型：<em><strong>type(被查看类型的数据)</strong></em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用print直接输出类型信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">666</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">3.1415926</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用变量储存type()语句的结果</span></span><br><span class="line">string_type = <span class="built_in">type</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">int_type = <span class="built_in">type</span>(<span class="number">666</span>)</span><br><span class="line">float_type = <span class="built_in">type</span>(<span class="number">3.1415926</span>)</span><br><span class="line"><span class="built_in">print</span>(string_type)</span><br><span class="line"><span class="built_in">print</span>(int_type)</span><br><span class="line"><span class="built_in">print</span>(float_type)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用type()语句，查看存储的数据类型信息</span></span><br><span class="line">name = <span class="number">2.71828</span></span><br><span class="line">name_type = <span class="built_in">type</span>(name)</span><br><span class="line"><span class="built_in">print</span>(name_type)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>python中变量是没有类型的，而变量储存的数据是有类型的</strong></p>
<h2 id="数据类型转化"><a href="#数据类型转化" class="headerlink" title="数据类型转化"></a>数据类型转化</h2><p>数据类型转化使用场景：</p>
<ul>
<li>从文件中读取数字，默认是字符串，我们需要转换成数字类型</li>
<li>input()语句，默认结果是字符串，若需要数字也需要转化</li>
</ul>
<p>………</p>
<p>常见转换语句</p>
<table>
<thead>
<tr>
<th>语句(函数)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int(x)</td>
<td>将x转换成一个整数</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换成一个浮点数</td>
</tr>
<tr>
<td>str(x)</td>
<td>将x转换成字符串</td>
</tr>
</tbody></table>
<p>PS：同前面的type()语句一样，这三个语句都是带有结果的（返回值），我们可以直接用print输出，或用变量存储返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将数字类型转换成字符串类型</span></span><br><span class="line">num_str = <span class="built_in">str</span>(<span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num_str),num_str)</span><br><span class="line"></span><br><span class="line">float_str = <span class="built_in">str</span>(<span class="number">3.14</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(float_str),float_str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串转换成数字</span></span><br><span class="line">num1 = <span class="built_in">int</span>(<span class="string">&quot;1234&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num1),num1)</span><br><span class="line"></span><br><span class="line">num2 = <span class="built_in">float</span>(<span class="string">&quot;11&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num2),num2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数转浮点</span></span><br><span class="line">float_num = <span class="built_in">float</span>(<span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(float_num),float_num)</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>任意类型都可以转换成字符串，但字符串中有数字才可以转换成数字类型</li>
<li>浮点型可以转换成整型，但会精度损失（小数部分丢失）</li>
</ul>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在python中，我们可以给许多东西起名字，如</p>
<ul>
<li>变量名字</li>
<li>方法名字</li>
<li>类的名字</li>
</ul>
<p>……</p>
<p>这些名字，我们把它统一的称之为标识符，用来做内容的标识</p>
<p><strong>标识符命名规则</strong></p>
<ul>
<li>只允许使用<strong>英文</strong>，中文（不推荐），<strong>数字</strong>，<strong>下划线</strong>这四种内容</li>
<li>数字不可以开头</li>
<li>区分大小写</li>
<li>不可以使用关键字</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符（数学运算符）"><a href="#算数运算符（数学运算符）" class="headerlink" title="算数运算符（数学运算符）"></a>算数运算符（数学运算符）</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">加</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘</td>
</tr>
<tr>
<td align="center">&#x2F;</td>
<td align="center">除</td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F;</td>
<td align="center">取整除</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">取余</td>
</tr>
<tr>
<td align="center">**</td>
<td align="center">指数</td>
</tr>
</tbody></table>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td align="center">赋值运算符</td>
</tr>
</tbody></table>
<h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+&#x3D;</td>
<td align="center">加法赋值运算符</td>
<td align="center">c +&#x3D; a等效于c &#x3D; c + a</td>
</tr>
<tr>
<td align="center">-&#x3D;</td>
<td align="center">减法赋值运算符</td>
<td align="center">c -&#x3D; a等效于c &#x3D; c - a</td>
</tr>
<tr>
<td align="center">*&#x3D;</td>
<td align="center">乘法赋值运算符</td>
<td align="center">c *&#x3D; a等效于c &#x3D; c * a</td>
</tr>
<tr>
<td align="center">&#x2F;&#x3D;</td>
<td align="center">除法赋值运算符</td>
<td align="center">c &#x2F;&#x3D; a等效于c &#x3D; c &#x2F; a</td>
</tr>
<tr>
<td align="center">%&#x3D;</td>
<td align="center">取模赋值运算符</td>
<td align="center">c %&#x3D; a等效于c &#x3D; c % a</td>
</tr>
<tr>
<td align="center">**&#x3D;</td>
<td align="center">幂赋值运算符</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F;&#x3D;</td>
<td align="center">取整除赋值运算符</td>
<td align="center">c &#x2F;&#x2F;&#x3D; a等效于c &#x3D; c &#x2F;&#x2F; a</td>
</tr>
</tbody></table>
<h2 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h2><h3 id="三种定义方法"><a href="#三种定义方法" class="headerlink" title="三种定义方法"></a>三种定义方法</h3><p>字符串在python中有多种定义形式</p>
<ol>
<li>单引号定义法：name &#x3D; ‘hello’</li>
<li>双引号定义法：name &#x3D; “hello”</li>
<li>三引号定义法：name &#x3D; “”” hello “””</li>
</ol>
<p>PS：三引号定义法，和多行注释的写法一样，同样支持换行操作。</p>
<p>使用变量接收它，他就是字符串，否则是多行注释</p>
<p>如果想在字符串中使用单引号或双引号：</p>
<ul>
<li>单引号定义法，可以内含双引号</li>
<li>双引号定义法，可以内含单引号</li>
<li>使用转义字符（\）</li>
</ul>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>如果我们有多个字符串，可以通过“**+**”将其拼接成一个字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello &quot;</span>+<span class="string">&quot;world&quot;</span>)</span><br><span class="line">str1 = <span class="string">&quot;大家好&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;我用Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1 + <span class="string">&quot;，人生苦短，&quot;</span> + str2)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">大家好，人生苦短，我用Python</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>”+“无法将非字符串类型的数据拼接</p>
<h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>由于拼接字符串变量过多时拼接太麻烦，且字符串无法和数字或其他类型完成拼接，因而引入字符串的格式化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="number">64</span></span><br><span class="line">str2 = <span class="number">8</span></span><br><span class="line">message = <span class="string">&quot;%s除以%s等于%s&quot;</span> % (str1,str2,str2)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">64除以8等于8</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中的，%s</p>
<ul>
<li>%表示：我要占位</li>
<li>s表示：将变量变成字符串放入占位的地方</li>
</ul>
<p>所以，综合起来的意思就是：我先占个位置，等一会有个变量过来，我把它变成字符串放到占位的位置</p>
<p>注意：多个变量占位，变量要用括号括起来，并且按照占位的顺序填入</p>
<p>Python中最常用的三类占位，用法和上文%s用法类似</p>
<table>
<thead>
<tr>
<th align="center">格式符号</th>
<th align="center">转化</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%s</td>
<td align="center">将内容转化为字符串，放入占位位置</td>
</tr>
<tr>
<td align="center">%d</td>
<td align="center">将内容转化成整数，放入占位位置</td>
</tr>
<tr>
<td align="center">%f</td>
<td align="center">将内容转化成浮点型，放入占位位置</td>
</tr>
</tbody></table>
<h3 id="格式化的精度控制"><a href="#格式化的精度控制" class="headerlink" title="格式化的精度控制"></a>格式化的精度控制</h3><p><strong>字符串格式化-数字精度控制</strong></p>
<p>我们可以使用辅助符号“m.n”来控制数据的宽度和精度</p>
<ul>
<li>m，控制宽度，要求是数字（很少使用），设置的宽度小于数字自身，不生效</li>
<li>.n，控制小数点精度，要求是数字，会进行小数的四舍五入</li>
</ul>
<h3 id="字符串格式化方法2"><a href="#字符串格式化方法2" class="headerlink" title="字符串格式化方法2"></a>字符串格式化方法2</h3><p>语法：</p>
<p>f”内容{变量}”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;2023年&quot;</span></span><br><span class="line">str2 = <span class="number">23</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;今年是<span class="subst">&#123;str1&#125;</span>，二十一世纪的第<span class="subst">&#123;str2&#125;</span>年&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">今年是2023年，二十一世纪的第23年</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这种方式不理会类型，不做精度控制，适合对精度没有要求的时候快速使用</p>
<h3 id="对表达式进行格式化"><a href="#对表达式进行格式化" class="headerlink" title="对表达式进行格式化"></a>对表达式进行格式化</h3><p>表达式：一条具有明确<strong>执行结果</strong>的<strong>代码语句</strong></p>
<p>格式化表达式：</p>
<ul>
<li>f”{表达式}”</li>
<li>“ %s \ %d \ %f “ % (表达式)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1 * 1 的结果是：%d&quot;</span> % (<span class="number">1</span> * <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;1 * 2 的结果是：<span class="subst">&#123;<span class="number">1</span>*<span class="number">2</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串在Python中的类型名是：%s&quot;</span> % <span class="built_in">type</span>(<span class="string">&quot;字符串&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">1 * 1 的结果是：1</span></span><br><span class="line"><span class="string">1 * 2 的结果是：2</span></span><br><span class="line"><span class="string">字符串在Python中的类型名是：&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>在无需使用变量进行数据存储的时候，可以直接格式化表达式简化代码</p>
<h2 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h2><p>前面使用print语句输出，在Python中，与之对应还有一个input语句，来获取键盘输入</p>
<ul>
<li>数据输出：print</li>
<li>数据输入：input</li>
</ul>
<p>使用方法：</p>
<ul>
<li>使用input()语句可以从键盘上获取输入</li>
<li>使用一个变量接收（存储）input语句获取的键盘输入数据即可</li>
<li>获取的数据永远都是字符串类型</li>
<li>可以使用：**input(“提示信息”)**，用以在使用输入内容之前显示提示信息</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown语法学习</title>
    <url>/2023/04/22/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Markdown语法学习"><a href="#Markdown语法学习" class="headerlink" title="Markdown语法学习"></a>Markdown语法学习</h1><h2 id="Markdown介绍"><a href="#Markdown介绍" class="headerlink" title="Markdown介绍"></a>Markdown介绍</h2><p>Markdown是一种轻量级标记语言，它使用纯文本格式编写，可通过转换工具将其转换成 HTML、PDF 和其他格式，常用于撰写技术文档、博客、论坛帖子等。它语法简单、清晰易读，可以让写作者更加专注于内容的表达和组织，减少排版和格式化的时间，提高效率和创作体验。</p>
<h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><ul>
<li>VS Code： 轻量级文本编辑器，插件丰富，可拓展性强</li>
<li>Typora：UI简洁，所见即所得</li>
</ul>
<h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><p>几个”#”即表示几级标签，共六级标题，字体大小依次减小</p>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**加粗内容**</span></span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p><strong>加粗内容</strong></p>
<h3 id="倾斜"><a href="#倾斜" class="headerlink" title="倾斜"></a>倾斜</h3><p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*倾斜内容1*</span></span><br><span class="line"><span class="emphasis">_倾斜内容2_</span></span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p><em>倾斜内容1</em></p>
<p><em>倾斜内容2</em></p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p><u>下划线</u></p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~删除~~</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p><del>删除</del></p>
<h3 id="标记（高亮）"><a href="#标记（高亮）" class="headerlink" title="标记（高亮）"></a>标记（高亮）</h3><p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">==标记==</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p>&#x3D;&#x3D;标记&#x3D;&#x3D;</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用</span></span><br></pre></td></tr></table></figure>

<p>效果展示</p>
<blockquote>
<p>引用</p>
</blockquote>
<h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>代码（注意都是双标签，中间夹的为上(下)标内容）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">m^2^</span><br><span class="line">H~2~O</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p>m^2^</p>
<p>H<del>2</del>O</p>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 中国</span><br><span class="line">+ 辽宁</span><br><span class="line">* 沈阳</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<ul>
<li>中国<ul>
<li>辽宁<ul>
<li>沈阳</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 尤塞恩·博尔特</span><br><span class="line">2. 约翰·布雷克</span><br><span class="line">3. 泰森·盖伊</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<ol>
<li>尤塞恩·博尔特</li>
<li>约翰·布雷克</li>
<li>泰森·盖伊</li>
</ol>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>代码（”-“和”[ ]”之间有三个空格）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span>   [x] 早饭</span><br><span class="line"><span class="bullet">-</span>   [ ] 午饭</span><br><span class="line"><span class="bullet">-</span>   [ ] 晚饭</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
早饭</p>
</li>
<li><p><input disabled="" type="checkbox"> 
午饭</p>
</li>
<li><p><input disabled="" type="checkbox"> 
晚饭</p>
</li>
</ul>
<h2 id="公式代码"><a href="#公式代码" class="headerlink" title="公式代码"></a>公式代码</h2><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><p>代码（在”1”左边，注意要使用英文输入）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`int`</span> 整形</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p><code>int</code> 整形</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码（第一行”&#96;”后面的为语言类型，建议直接使用快捷键）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">````c</span><br><span class="line">void main()&#123;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line">````</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h3><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二倍角公式：$sin2x = 2sinxcosx$ </span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p> 二倍角公式：$sin2x &#x3D; 2sinxcosx$ </p>
<h3 id="公式块"><a href="#公式块" class="headerlink" title="公式块"></a>公式块</h3><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">E_&#123;\rm k&#125; = \frac 1 2 m v^2</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>效果展示：<br>$$<br>E_{\rm k} &#x3D; \frac 1 2 m v^2<br>$$</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|      |   小米   |   vivo   |</span><br><span class="line">| ---- | ---- | ---- |</span><br><span class="line">|   手机   |      |      |</span><br><span class="line">|   平板   |      |      |</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<table>
<thead>
<tr>
<th></th>
<th>小米</th>
<th>vivo</th>
</tr>
</thead>
<tbody><tr>
<td>手机</td>
<td></td>
<td></td>
</tr>
<tr>
<td>平板</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[哔哩哔哩](https://www.bilibili.com/)</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p><a href="https://www.bilibili.com/">哔哩哔哩</a></p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](图片路径)</span><br></pre></td></tr></table></figure>



<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[^1]</span><br></pre></td></tr></table></figure>



<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>代码（三个以上减号即可）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----</span><br></pre></td></tr></table></figure>



<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>Python集合(七)——异常、模块与包</title>
    <url>/2023/08/18/Python%E5%9F%BA%E7%A1%80(%E4%B8%83)%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E3%80%81%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</url>
    <content><![CDATA[<h1 id="了解异常"><a href="#了解异常" class="headerlink" title="了解异常"></a>了解异常</h1><ol>
<li><p>异常：</p>
<p>异常就是程序运行的过程中出现了错误</p>
</li>
<li><p>bug：</p>
<p>bug就是异常的意思，因为历史因为小虫子导致计算机失灵，所以延续至今，bug就代表软件出现错误</p>
</li>
</ol>
<h1 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h1><ol>
<li><p>为什么要捕获异常？</p>
<p>在可能发生异常的地方进行捕获。当发生异常的时候，提供解决方式，而不是任由其导致程序无法运行</p>
</li>
<li><p>捕获异常的语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能要发生异常的语句</span><br><span class="line"><span class="keyword">except</span> [异常 <span class="keyword">as</span> 别名]:</span><br><span class="line">    出现异常的准备手段</span><br><span class="line">[<span class="keyword">else</span>:]</span><br><span class="line">	未出现异常时应做的事情</span><br><span class="line">[<span class="keyword">finally</span>]:</span><br><span class="line">    不管出不出现异常都会做的事情</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 带有中括号的内容可以不写，基础写法就是try-except组合</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>捕获所有异常</p>
<p>异常的种类多种多样，如果想要不管什么类型的异常都能捕获到，那么使用：</p>
<ul>
<li>except:</li>
<li>except Exception:</li>
</ul>
</li>
</ol>
<h1 id="异常的传递"><a href="#异常的传递" class="headerlink" title="异常的传递"></a>异常的传递</h1><p>异常时具有传递性的，当出现异常，且所有函数都没有捕获异常的时候，程序就会报错</p>
<h1 id="Python模块"><a href="#Python模块" class="headerlink" title="Python模块"></a>Python模块</h1><h2 id="模块的导入"><a href="#模块的导入" class="headerlink" title="模块的导入"></a>模块的导入</h2><ol>
<li><p>模块：</p>
<p>模块就是一个Python代码文件，内含类、函数、变量等，我们可以导入进行使用。</p>
</li>
<li><p>导入模块：</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">from</span> 模块名] <span class="keyword">import</span> [模块 | 类 | 变量 | 函数 | *] [<span class="keyword">as</span> 别名]</span><br></pre></td></tr></table></figure>

<p>演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">演示Python的模块导入</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用import导入time模块使用sleep功能（函数）</span></span><br><span class="line"><span class="keyword">import</span> time         <span class="comment"># 导入Python内置的time模块（time.py这个代码文件）</span></span><br><span class="line">time.sleep(<span class="number">5</span>)       <span class="comment"># 通过 . 就可以使用模块的功能</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;###########&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用from导入time的sleep功能（函数）</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;###########&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 * 导入time模块的全部功能</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;###########&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用as给特定功能加上别名</span></span><br><span class="line"><span class="keyword">import</span> time <span class="keyword">as</span> t</span><br><span class="line">t.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep <span class="keyword">as</span> sl</span><br><span class="line">sl(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：</p>
<ul>
<li>from可以省略，直接import即可</li>
<li>as别名可以省略</li>
<li>通过“.”来确定层级关系</li>
<li>模块的导入一般写在代码文件的开头位置</li>
</ul>
</li>
</ol>
<h2 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h2><ol>
<li><p>自定义模块并导入：</p>
<p>在Python代码文件中正常写代码即可，通过import、from关键字和导入Python内置模块一样导入即可使用</p>
</li>
<li><p><code>__mian__</code>变量的功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:表示，只有当程序时直接执行的才会进入if内部，如果是被导入的，则if无法进入</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：</p>
<ul>
<li><p>不同模块，同名功能，如果都被导入，那么后导入的会覆盖先导入的</p>
</li>
<li><p><code>__all__</code>变量可以控制 import* 的哪些功能可以被导入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;a&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Python包"><a href="#Python包" class="headerlink" title="Python包"></a>Python包</h1><h2 id="自定义包"><a href="#自定义包" class="headerlink" title="自定义包"></a>自定义包</h2><ol>
<li><p>Python包：</p>
<p>包就是一个文件夹，里面可以存放许多Python模块（代码文件），通过包，在逻辑上将一批模块归为一类，方便使用</p>
</li>
<li><p><code>__init__.py</code>文件作用：</p>
<p>创建包会默认自动创建的文件，通过这个文件表示一个文件夹是Python的包，而非普通的文件夹</p>
</li>
<li><p><code>__all__</code>变量的作用：</p>
<p>同模块，控制import *能够导入的内容</p>
</li>
</ol>
<h2 id="安装第三方包"><a href="#安装第三方包" class="headerlink" title="安装第三方包"></a>安装第三方包</h2><ol>
<li><p>什么是第三方包？有什么作用？</p>
<p>第三方包就是非Python官方内置的包，可以安装他们拓展功能，提高开发效率</p>
</li>
<li><p>如何安装？</p>
<ul>
<li>在命令提示符内：<ul>
<li>pip install 包名称</li>
<li>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> 包名称</li>
</ul>
</li>
<li>在PyCharm中安装</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础(二)——判断、循环</title>
    <url>/2023/07/14/Python%E5%9F%BA%E7%A1%80(%E4%BA%8C)%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E3%80%81%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><p>进行逻辑判断是生活中常见的行为，同样，在程序中，进行逻辑判断也是最为基础的功能</p>
<h2 id="布尔类型和比较运算符"><a href="#布尔类型和比较运算符" class="headerlink" title="布尔类型和比较运算符"></a>布尔类型和比较运算符</h2><h3 id="布尔类型的定义"><a href="#布尔类型的定义" class="headerlink" title="布尔类型的定义"></a>布尔类型的定义</h3><p>布尔类型的字面量：</p>
<ul>
<li>True 表示真（是、肯定）</li>
<li>False 表示假（否、否定）</li>
</ul>
<p>定义变量存储布尔类型数据：</p>
<p>变量名称 &#x3D; 布尔类型字面量</p>
<p>布尔类型不仅可以自行定义，也可以使用比较运算符得到布尔类型的结果</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;&#x3D;</td>
<td align="center">判断内容是否相等，满足为True，否则为False</td>
</tr>
<tr>
<td align="center">!&#x3D;</td>
<td align="center">判断内容是否不相等，满足为True，否则为False</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">判断内容左侧内容是否大于右侧，满足为True，否则为False</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">判断内容左侧内容是否小于右侧，满足为True，否则为False</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td align="center">判断内容左侧内容是否大于等于右侧，满足为True，否则为False</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="center">判断内容左侧内容是否小于等于右侧，满足为True，否则为False</td>
</tr>
</tbody></table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bool_1 = <span class="literal">True</span></span><br><span class="line">bool_2 = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bool_1变量内容：<span class="subst">&#123;bool_1&#125;</span>,类型是：<span class="subst">&#123;<span class="built_in">type</span>(bool_1)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bool_1变量内容：<span class="subst">&#123;bool_2&#125;</span>,类型是：<span class="subst">&#123;<span class="built_in">type</span>(bool_2)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">num_1 = <span class="number">10</span></span><br><span class="line">num_2 = <span class="number">10</span></span><br><span class="line">num_3 = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;10 == 10 的结果：<span class="subst">&#123;num_1 == num_2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;10 == 100 的结果：<span class="subst">&#123;num_1 == num_3&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">bool_1变量内容：True,类型是：&lt;class &#x27;bool&#x27;&gt;</span></span><br><span class="line"><span class="string">bool_1变量内容：False,类型是：&lt;class &#x27;bool&#x27;&gt;</span></span><br><span class="line"><span class="string">10 == 10 的结果：True</span></span><br><span class="line"><span class="string">10 == 100 的结果：False</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>





<h2 id="if语句的基本格式"><a href="#if语句的基本格式" class="headerlink" title="if语句的基本格式"></a>if语句的基本格式</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>if  要判断的条件:</p>
<p>​    条件成立是，要执行的语句</p>
<p><strong>注意</strong>：条件结果一定是布尔类型，条件后面要加<strong>冒号</strong>，归属于if语句的代码块前方要有<strong>四个空格！！！</strong></p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">30</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我已经成年了&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;离我的18岁越来越远了&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;时间过得真快呀&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我已经成年了</span></span><br><span class="line"><span class="string">离我的18岁越来越远了</span></span><br><span class="line"><span class="string">时间过得真快呀</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>if  条件:</p>
<p>​    满足条件时执行语句1</p>
<p>​	满足条件时执行语句2</p>
<p>else:</p>
<p>​	不满足条件时执行语句1</p>
<p>​    不满足条件时执行语句2</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;欢迎来到黑马儿童游乐园，儿童免费，成人收费。\n请输入你的年龄：&quot;</span>)</span><br><span class="line">age = <span class="built_in">int</span>(age)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;您已成年，游玩需要补票10元&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;您未成年，可以免费游玩&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;祝您游玩愉快&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="if-elif-else"><a href="#if-elif-else" class="headerlink" title="if-elif-else"></a>if-elif-else</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>if  条件1:</p>
<p>​    满足条件1时执行语句1</p>
<p>​	满足条件1时执行语句2</p>
<p>elif 条件2:</p>
<p>​	满足条件2时执行语句1</p>
<p>​    满足条件2时执行语句2</p>
<p>elif 条件N:</p>
<p>​	满足条件N时执行语句1</p>
<p>​    满足条件N时执行语句2</p>
<p>else:</p>
<p>​	不满足所有条件时执行语句1</p>
<p>​    不满足所有条件时执行语句2</p>
<p><strong>注意</strong>：判断是互斥且有顺序的，else可以省略不写，效果等同3个独立的if判断，可以在判断语句中直接写input语句，节省代码量</p>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入第一次猜想的数字：&quot;</span>)) == <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;恭喜第一次就猜对啦&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;不对，再猜一次：&quot;</span>)) == <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;猜对啦&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;不对，再猜最后一次：&quot;</span>)) == <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;猜对啦&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sorry,全部猜错啦，我想的是：10&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="判断语句的嵌套"><a href="#判断语句的嵌套" class="headerlink" title="判断语句的嵌套"></a>判断语句的嵌套</h2><p>有很多场景，不仅仅是多个并置条件，还会有满足前置条件才会二次判断的多层判断需求，对于这种需求，可以通过判断语句的嵌套</p>
<p><strong>注意：</strong></p>
<ul>
<li>判断语句可以用于多条件，多层次的逻辑判断</li>
<li>嵌套判断语句可以根据需求，自由组合if-elif-else来构建多层次判断</li>
<li>嵌套判断语句，一定要注意空格缩进，Python通过空格缩进来决定层次关系</li>
</ul>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>循环在程序中同判断一样，也是广泛存在的，是非常多功能实现的基础</p>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>while 条件:</p>
<p>​    条件满足时，执行语句1</p>
<p>​	条件满足时，执行语句2</p>
<p>​	……</p>
<p><strong>注意：</strong></p>
<ul>
<li>while的条件时布尔类型，True表示继续循环，False结束循环</li>
<li><strong>空格缩进同if</strong></li>
</ul>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>九九乘法表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">9</span>:</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= i:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d * %d = %d\t&quot;</span> % (j,i,i*j),end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>for 临时变量 in 待处理数据集:</p>
<p>​    循环满足条件时执行语句</p>
<p><strong>注意：</strong></p>
<ul>
<li>同while循环不同，python中for循环是无法定义循环条件的，只能从处理的数据集中依次取出内容进行处理，所有理论上for循环无法构建无限循环（被处理的数据集不可能无限大）</li>
<li>语法中，待处理数据集严格来说称之为：序列类型，其内容可以一个个依次取出的一种类型，包括字符串，列表，元组等</li>
<li>注意空格缩进</li>
</ul>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>遍历字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> name:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">h</span></span><br><span class="line"><span class="string">e</span></span><br><span class="line"><span class="string">l</span></span><br><span class="line"><span class="string">l</span></span><br><span class="line"><span class="string">o</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看出，for循环是将字符串的内容<strong>依次取出</strong>，所有for循环也被称为“遍历循环”</p>
<h2 id="循环中断：break和continue"><a href="#循环中断：break和continue" class="headerlink" title="循环中断：break和continue"></a>循环中断：break和continue</h2><ul>
<li>continue：中断本次循环，直接进入下一次循环</li>
<li>break：直接结束所在循环</li>
</ul>
<h2 id="while循环和for循环的一些区别"><a href="#while循环和for循环的一些区别" class="headerlink" title="while循环和for循环的一些区别"></a>while循环和for循环的一些区别</h2><ul>
<li>while循环的循环条件时自定义的，自行控制循环条件</li>
<li>for循环是一种“轮询”机制，是对一批内容进行“逐个处理”</li>
</ul>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">num = random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 随机生成一个1到10的整数</span></span><br></pre></td></tr></table></figure>



<h2 id="end-x3D-‘’"><a href="#end-x3D-‘’" class="headerlink" title="end &#x3D; ‘’"></a>end &#x3D; ‘’</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">world</span></span><br><span class="line"><span class="string">helloworld</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="制表符-t"><a href="#制表符-t" class="headerlink" title="制表符\t"></a>制表符\t</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hihi Shenyang&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\tworld&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hihi\tShenyang&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">hihi Shenyang</span></span><br><span class="line"><span class="string">hello	world</span></span><br><span class="line"><span class="string">hihi	Shenyang</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="range语句"><a href="#range语句" class="headerlink" title="range语句"></a>range语句</h2><p>语法1：</p>
<p><strong>range(num)</strong></p>
<p>获取一个从0开始，到num结束的数字序列（不含num本身）</p>
<p>如，range(5)取得的数据是：[0,1,2,3,4]</p>
<p>语法2：</p>
<p><strong>range(num1,num2)</strong></p>
<p>获取一个从num1开始，到num2结束的数字序列（不含num2本身）</p>
<p>如，range(5，10)取得的数据是：[5,6,7,8,9]</p>
<p>语法3：</p>
<p><strong>range(num1,num2,step)</strong></p>
<p>获取一个从num1开始，到num2结束的数字序列（不含num2本身）</p>
<p>数字之间的步长，以step为准（step默认为1）</p>
<p>如，range(5,10,2)取得的数据是：[5,7,9]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">100</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,num):</span><br><span class="line">    <span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;从1到<span class="subst">&#123;num&#125;</span>(不含<span class="subst">&#123;num&#125;</span>本身)共有<span class="subst">&#123;count&#125;</span>个偶数&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">从1到100(不含100本身)共有49个偶数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础(五)——函数拓展</title>
    <url>/2023/08/15/Python%E5%9F%BA%E7%A1%80(%E4%BA%94)%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[<h1 id="函数的多返回值"><a href="#函数的多返回值" class="headerlink" title="函数的多返回值"></a>函数的多返回值</h1><p> 使用多个变量接收多个返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">x,y,z = test()    <span class="comment"># x为1，y为&quot;hello&quot;,z为True</span></span><br></pre></td></tr></table></figure>





<h1 id="函数多种传参方式"><a href="#函数多种传参方式" class="headerlink" title="函数多种传参方式"></a>函数多种传参方式</h1><h2 id="函数参数种类"><a href="#函数参数种类" class="headerlink" title="函数参数种类"></a>函数参数种类</h2><p>使用方式上的不同，函数有4钟常见参数使用方式：</p>
<ul>
<li>位置参数</li>
<li>关键字参数</li>
<li>缺省参数</li>
<li>不定长参数</li>
</ul>
<h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><p>位置参数：调用函数时根据函数定义的参数位置来传递函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name,age,gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;您的名字是<span class="subst">&#123;name&#125;</span>,年龄是<span class="subst">&#123;age&#125;</span>,性别是<span class="subst">&#123;gender&#125;</span>)</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">user_info(&#x27;Tom&#x27;,20,&#x27;男&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>注意：传递的参数和定义的参数的顺序及个数必须一致</p>
<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>关键字参数：函数调用时通过”键&#x3D;值“形式传递参数</p>
<p>作用：可以让函数更加清晰、容易使用，同时也清楚了参数的顺序需求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name,age,gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;您的名字是<span class="subst">&#123;name&#125;</span>,年龄是<span class="subst">&#123;age&#125;</span>,性别是<span class="subst">&#123;gender&#125;</span>)</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string"># 关键字传参</span></span><br><span class="line"><span class="string">user_info(name=&#x27;Tom&#x27;, age=20, gender=&#x27;男&#x27;) </span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string"># 可以不按照顺序</span></span><br><span class="line"><span class="string">user_info(age=20, name=&#x27;Tom&#x27;, agender=&#x27;男&#x27;) </span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string"># 可以和位置参数混用，位置参数必须在前，且匹配参数顺序</span></span><br><span class="line"><span class="string">user_info(&#x27;Tom&#x27;, age=20, gender=&#x27;男&#x27;)           </span></span><br></pre></td></tr></table></figure>

<p>注意：函数调用时，如果有位置参数时，位置参数必须在关键字参数前面，但关键字参数之间不存在先后顺序</p>
<h2 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h2><p>缺省参数：缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）</p>
<p>作用：当调用函数时没有传递函数，就会使用默认使用缺省参数对应的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name,age,gender=<span class="string">&#x27;男&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;您的名字是<span class="subst">&#123;name&#125;</span>,年龄是<span class="subst">&#123;age&#125;</span>,性别是<span class="subst">&#123;gender&#125;</span>)</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">user_info(&#x27;Tom&#x27;, 20)</span></span><br><span class="line"><span class="string">user_info(&#x27;Rose&#x27;, 18, &#x27;女&#x27;)          </span></span><br></pre></td></tr></table></figure>

<p>注意：函数调用时，如果为缺省参数传值则修改默认参数值，否则使用这个默认值</p>
<h2 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h2><p>不定长参数：不定长参数也叫可变参数，用于不确定调用的时候会传递多少个参数（不传参也可以）的场景</p>
<p>作用：当调用函数时不确定参数个数时，可以使用不定长参数</p>
<p>不定长参数的类型：</p>
<ul>
<li><p>位置传递</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># (&#x27;Tom&#x27;)</span></span><br><span class="line">user_info(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (&#x27;Tom&#x27;,18)</span></span><br><span class="line">user_info(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>注意：传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型</p>
</li>
<li><p>关键字传递</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;:&#x27;Tom&#x27;, &#x27;age&#x27;:18, &#x27;id&#x27;:110&#125;</span></span><br><span class="line">user_info(name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">18</span>, <span class="built_in">id</span>=<span class="number">110</span>)</span><br></pre></td></tr></table></figure>

<p>注意：参数是”键&#x3D;值“形式的情况下，所有的”键&#x3D;值“都会被kwargs接受，同时会根据”键&#x3D;值“组成字典</p>
</li>
</ul>
<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><h2 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h2><ul>
<li>函数本身可以作为参数，传入另一个函数中使用</li>
<li>这是一种计算逻辑的传递，而非数据的传递</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>(<span class="params">computer</span>):</span><br><span class="line">    result = computer(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;compute函数的类型是；<span class="subst">&#123;<span class="built_in">type</span>(computer)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;计算结果：<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compter</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">text(computer)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果</span></span><br><span class="line"><span class="string">compute函数的类型是；&lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"><span class="string">计算结果：3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="lambda匿名函数"><a href="#lambda匿名函数" class="headerlink" title="lambda匿名函数"></a>lambda匿名函数</h2><p>函数的定义中</p>
<ul>
<li>def关键字，可以定义带有名称的函数，可以基于名称重复使用</li>
<li>lambda关键字，可以定义匿名函数（无名称），只可以临时使用一次</li>
</ul>
<p>匿名函数定义语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 传入参数:函数体(一行代码)</span><br></pre></td></tr></table></figure>

<ul>
<li>lambda是关键字，表示定义匿名函数</li>
<li>传入参数表示匿名函数的形式参数，如：x,y表示接受2个形式参数</li>
<li>函数体，就是函数的执行逻辑，要注意：只能写一行，无法写多行代码</li>
</ul>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>(<span class="params">computer</span>):</span><br><span class="line">    result = computer(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;compute函数的类型是；<span class="subst">&#123;<span class="built_in">type</span>(computer)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;计算结果：<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compter</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">text(computer)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用lambda表达式将上述代码简化，如下</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>(<span class="params">computer</span>):</span><br><span class="line">    result = computer(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;compute函数的类型是；<span class="subst">&#123;<span class="built_in">type</span>(computer)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;计算结果：<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">text(<span class="keyword">lambda</span> x,y: x+y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两段代码作用和运行结果完全一致</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础(三)——函数</title>
    <url>/2023/08/12/Python%E5%9F%BA%E7%A1%80(%E4%B8%89)%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h1><ul>
<li>函数是组织好的，可重复使用的，用来实现特定功能的代码段，如前面的type()、input()等都是Python的内置函数。</li>
<li>函数可以提高程序的复用性，减少重复性代码，提高开发效率</li>
</ul>
<h1 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">传入参数</span>):</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">函数名(参数)</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong></p>
<ul>
<li>参数如果不需要，可以省略</li>
<li>返回值如果不需要，可以省略</li>
<li>函数必须先定义后使用</li>
</ul>
<h1 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h1><p>传入参数的功能是：在函数进行计算的时候，接受外部（调用时）提供的数据</p>
<p><strong>语法解析：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    result =  x + y</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span> + <span class="subst">&#123;y&#125;</span>的结果是：<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">add(<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>函数定义中，提供的x和y，称之为：形式参数（形参），表示函数声明将要使用2个参数，参数直接使用逗号进行分隔</li>
<li>函数调用中，提供的5和6，称之为：实际参数（实参），表示函数执行时真正使用的参数值，传入的时候，按照顺序传入数据，使用逗号分隔</li>
<li>传入参数的数量是不受限制的，可以没有，也可以有多个</li>
</ul>
<h1 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h1><h2 id="返回值的定义"><a href="#返回值的定义" class="headerlink" title="返回值的定义"></a>返回值的定义</h2><p>所谓返回值，就是程序中函数完成事情后，最后给调用者的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数</span>(<span class="params">参数...</span>):</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line"></span><br><span class="line">变量 = 函数(参数)</span><br></pre></td></tr></table></figure>

<p>如上述代码，变量就能接收到函数的返回值</p>
<p>语法就是：通过return关键字，就能向调用者返回数据</p>
<p><strong>注意：</strong>函数体在遇到return后就结束了，所以写在return后的代码不会执行</p>
<h2 id="None类型"><a href="#None类型" class="headerlink" title="None类型"></a>None类型</h2><p>Python中有一个特殊的字面量：None，其类型是：&lt;class ‘NoneType’&gt;，无返回值的函数，实际上就是返回了：None这个字面量</p>
<p>应用场景：</p>
<ul>
<li>用在函数<strong>无返回值</strong>上</li>
<li>用在<strong>if判断</strong>上，在if判断中，None等同于False，一般用在函数中主动返回None，配合if判断做出相关处理</li>
<li>在声明无内容的变量上，<strong>定义变量</strong>时，但暂时不需要变量有具体值，可以用None来代替</li>
</ul>
<p>None在if中的应用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_age</span>(<span class="params">age</span>):</span><br><span class="line">    <span class="keyword">if</span> age &gt; <span class="number">18</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">result = check_age(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未成年&quot;</span>)</span><br></pre></td></tr></table></figure>



<h1 id="函数说明文档"><a href="#函数说明文档" class="headerlink" title="函数说明文档"></a>函数说明文档</h1><p>顾名思义，就是在函数中写注释函数进行说明解释，帮助更好理解函数的功能</p>
<h1 id="函数的嵌套调用"><a href="#函数的嵌套调用" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h1><p>所谓函数嵌套调用就是指在一个函数里面调用了另外一个函数，如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun_b</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---2---&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun_a</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---1---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fun_b()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---3---&quot;</span>)</span><br><span class="line"></span><br><span class="line">fun_a()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">本段代码在fun_a中调用了fun_b</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">---1---</span></span><br><span class="line"><span class="string">---2---</span></span><br><span class="line"><span class="string">---3---</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><ol>
<li>变量主要分为局部变量和全局变量</li>
<li>局部变量：定义在函数体内的局部变量，即只在函数体内部生效</li>
<li>全局变量：在函数体内、外都能生效的变量</li>
<li>在函数内部定义一个与全局变量同名的变量，并对其运算，对全局变量无影响</li>
<li>在函数内部声明全局变量，需要使用global关键字</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础(八)——面向对象</title>
    <url>/2023/08/23/Python%E5%9F%BA%E7%A1%80(%E5%85%AB)%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h1><ol>
<li><p>类的组成：</p>
<ul>
<li>类的属性，称之为：成员变量</li>
<li>类的行为，称之为：成员方法、</li>
</ul>
<p>注意：函数是写在类外的，定义在类内部，我们都称之为方法</p>
</li>
<li><p>类和成员方法的定义语法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名称</span>:</span><br><span class="line">    成员变量</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">成员方法</span>(<span class="params">self,参数列表</span>):</span><br><span class="line">        成员方法体</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">对象 = 类名称()</span><br></pre></td></tr></table></figure>
</li>
<li><p>self的作用</p>
<ul>
<li>表示类对象本身的意思</li>
<li>只有通过self，成员方法才能访问类的成员变量</li>
<li>self出现在形参列表中，但是不占用参数位置，无需理会</li>
</ul>
</li>
</ol>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><ol>
<li><p>类和对象的关系：</p>
<p>类就是程序中的“设计图纸”，对象是基于图纸生产的具体实体</p>
</li>
<li><p>什么是面向对象编程：</p>
<p>面向对象编程就是使用对象编程。</p>
<p>即设计类，基于类创建对象，并使用对象来完成具体的工作</p>
</li>
</ol>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><ol>
<li>构造方法的名称：<code>__init__</code>，init前后是两个下划线</li>
<li>构造方法的作用：<ul>
<li>构建对象的时候会自动运行</li>
<li>构建类对象的传参会传递给构造方法，借此特性可以给成员变量赋值</li>
</ul>
</li>
<li>注意事项：<ul>
<li>构造方法不要忘记self关键字</li>
<li>在方法内使用成员需要使用self</li>
</ul>
</li>
</ol>
<h1 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h1><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>__init__</code></td>
<td>构造方法，可用于创建类对象的时候设置初始化行为</td>
</tr>
<tr>
<td><code>__str__</code></td>
<td>用于实现类对象转字符串的行为</td>
</tr>
<tr>
<td><code>__lt__</code></td>
<td>用于2个类对象进行小于或大于比较</td>
</tr>
<tr>
<td><code>__le__</code></td>
<td>用于2个类对象进行小于等于或大于等于比较</td>
</tr>
<tr>
<td><code>__eq__</code></td>
<td>用于2个类对象进行相等比较</td>
</tr>
</tbody></table>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ol>
<li><p>封装的概念：将现实世界事物在类中描述为属性和方法，即为封装</p>
</li>
<li><p>什么是私有成员？为什么需要私有成员？</p>
<p>现实事物有部分属性和行为是不公开对使用者开放的。同样在类中描述属性和方法的时候也需要达到这个要求，就需要私有成员了</p>
</li>
<li><p>如何定义私有成员：</p>
<p>成员变量和成员方法的命名均以<code>__</code>作为开头（两个下划线）</p>
</li>
<li><p>私有成员的访问限制：</p>
<ul>
<li>类对象无法访问私有成员</li>
<li>类中其他成员可以访问私有成员</li>
</ul>
</li>
</ol>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol>
<li><p>继承：继承就是一个类，继承了另一个类的成员变量和成员方法</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类</span>(父类<span class="number">1</span>,父类<span class="number">2</span>,……)</span><br><span class="line">	类体内容</span><br></pre></td></tr></table></figure>

<p>子类构建的类对象，可以</p>
<ul>
<li>有自己的成员变量和成员方法</li>
<li>使用父类的成员变量和成员方法</li>
</ul>
</li>
<li><p>单继承和多继承</p>
<ul>
<li>单继承：一个类继承另一个类</li>
<li>多继承：一个类继承多个类，按照顺序从左向右依次继承</li>
<li>多继承中，如果父类有同名方法或属性，先继承的优先级高于后继承</li>
</ul>
</li>
<li><p><code>pass</code>关键字的作用：</p>
<p>pass是占位语言，用来保证函数（方法）或类定义的完整性，表示无内容，空的意思</p>
</li>
<li><p>复写：对父类的成员属性或成员方法进行重新定义</p>
<p>语法：在子类中重新实现同名成员方法或成员属性即可</p>
</li>
<li><p>在子类中调用父类成员：</p>
<ul>
<li><p>方法一：</p>
<p>调用父类成员：</p>
<p>调用父类成员变量：<code>父类名.成员变量</code></p>
<p>调用父类成员方法：<code>父类名.成员方法(self)</code></p>
</li>
<li><p>方法二</p>
<p>使用super()调用父类成员</p>
<p>调用成员变量：<code>super().成员变量</code></p>
<p>调用成员方法：<code>super().成员方法()</code></p>
</li>
<li><p>注意：只可以在子类内部调用父类同名成员，子类的实体类调用默认是调用子类复写的</p>
</li>
</ul>
</li>
</ol>
<h1 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h1><h2 id="变量的类型注解"><a href="#变量的类型注解" class="headerlink" title="变量的类型注解"></a>变量的类型注解</h2><ol>
<li><p>什么是类型注解，有什么作用？</p>
<p>在代码中涉及数据交互之时，对数据类型进行显式的说明，可以帮助：</p>
<ul>
<li>PyCharm等开发工具对代码做类型推断协助做代码提示</li>
<li>开发者自身做类型类型的备注</li>
</ul>
</li>
<li><p>类型注解支持：</p>
<ul>
<li>变量的类型注解</li>
<li>函数（方法）的形参和返回值的类型注解</li>
</ul>
</li>
<li><p>变量的类型注解语法</p>
<ul>
<li>语法1：<code>变量:类型</code></li>
<li>语法2：在注释中，<code># type: 类型</code></li>
</ul>
</li>
<li><p>注意事项</p>
<p>类型注解只是提示性的，并非决定性的。数据类型和注解类型无法对应也不会导致错误</p>
</li>
</ol>
<h2 id="函数（方法）的类型注解"><a href="#函数（方法）的类型注解" class="headerlink" title="函数（方法）的类型注解"></a>函数（方法）的类型注解</h2><ol>
<li><p>函数（方法）可以为哪里添加注解？</p>
<ul>
<li>形参的类型注解</li>
<li>返回值的类型注解</li>
</ul>
</li>
<li><p>函数（方法）的类型注解语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数方法名</span>(<span class="params">形参: 类型,……,形参: 类型</span>) -&gt; 返回值类型:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>注意，返回值类型注解的符号使用： <code>-&gt;</code></p>
</li>
</ol>
<h2 id="Union类型"><a href="#Union类型" class="headerlink" title="Union类型"></a>Union类型</h2><ol>
<li><p>什么是Union类型？</p>
<p>使用Union可以定义联合类型注解</p>
</li>
<li><p>Union的使用方法</p>
<ul>
<li>导包：<code>from typing import Union</code></li>
<li>使用：<code>Union[类型,……,类型]</code></li>
</ul>
</li>
</ol>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ol>
<li><p>什么是多态？</p>
<p>多态指的是，同一行为，使用不同对象获得不同的状态</p>
<p>如，定义函数（方法），通过类型注解声明需要的父类对象，实际传入子类对象进行工作，从而获得不同的工作状态</p>
</li>
<li><p>什么是抽象类（接口）？</p>
<p>包含抽象方法的类，称之为抽象类。抽象方法是指：没有具体实现的方法（pass）称之为抽象方法</p>
</li>
<li><p>抽象类的作用</p>
<p>多用于顶层设计（设计标准），以便子类做具体实现。也是对子类的一种软性约束，要求子类必须复写（实现）父类的一些方法并配合多态使用，获得不同的工作状态</p>
</li>
</ol>
<p>​     </p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础(六)——文件操作</title>
    <url>/2023/08/17/Python%E5%9F%BA%E7%A1%80(%E5%85%AD)%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="文件的编码"><a href="#文件的编码" class="headerlink" title="文件的编码"></a>文件的编码</h1><ol>
<li><p>什么是编码？</p>
<p>编码是一种规则集合，记录了内容和二进制间进行相互转换的逻辑</p>
<p>编码有许多种，我们最常用的是UTF-8编码</p>
</li>
<li><p>为什么需要使用编码？</p>
<p>计算机只认识0和1，所以需要将内容翻译成0和1才能保存在计算机中。</p>
<p>同时也需要编码，将计算机保存的0和1，反向翻译回可以识别的内容。</p>
</li>
</ol>
<h1 id="文件的读取"><a href="#文件的读取" class="headerlink" title="文件的读取"></a>文件的读取</h1><p>操作汇总</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">文件对象 &#x3D; open(file,mode,encoding)</td>
<td align="center">打开文件获得文件对象</td>
</tr>
<tr>
<td align="center">文件对象.read(num)</td>
<td align="center">读取指定长度字节，不指定num则读取文件全部</td>
</tr>
<tr>
<td align="center">文件对象.readline()</td>
<td align="center">读取一行</td>
</tr>
<tr>
<td align="center">文件对象.readlines()</td>
<td align="center">读取全部行，得到列表</td>
</tr>
<tr>
<td align="center">for line in 文件对象</td>
<td align="center">for循环文件行，一次循环得到一行数据</td>
</tr>
<tr>
<td align="center">文件对象.close()</td>
<td align="center">关闭文件对象</td>
</tr>
<tr>
<td align="center">with open() as f</td>
<td align="center">通过with open语法打开文件，可以自动关闭</td>
</tr>
</tbody></table>
<h1 id="文件的写入"><a href="#文件的写入" class="headerlink" title="文件的写入"></a>文件的写入</h1><ol>
<li>写入文件使用open函数的”w“模式写入</li>
<li>写入的方法有：<ul>
<li>write()，写入内容</li>
<li>flush()，刷新内容到硬盘中</li>
</ul>
</li>
<li>注意事项：<ul>
<li>w模式，文件不存在，会创建新文件</li>
<li>w模式，文件存在，会清空原有内容</li>
<li>close()方法，带有flush()方法的功能</li>
</ul>
</li>
</ol>
<h1 id="文件的追加"><a href="#文件的追加" class="headerlink" title="文件的追加"></a>文件的追加</h1><ol>
<li>追加写入文件使用open函数的”a“模式写入</li>
<li>追加写入的方法有（和w模式一样）<ul>
<li>write()，写入内容</li>
<li>flush()，刷新内容到硬盘中</li>
</ul>
</li>
<li>注意事项：<ul>
<li>a模式，文件不存在，会创建新文件</li>
<li>a模式，文件存在，会在原有内容后面继续写入</li>
<li>可以使用”\n“来写出换行符</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础(四)——数据容器</title>
    <url>/2023/08/13/Python%E5%9F%BA%E7%A1%80(%E5%9B%9B)%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="数据容器入门"><a href="#数据容器入门" class="headerlink" title="数据容器入门"></a>数据容器入门</h1><p>Python中的数据容器：</p>
<p>一个可以容纳多份数据的数据类型，容纳的每一份元素称之为1个元素，每个元素可以是任意类型的数据，如字符串、数字、布尔等。</p>
<p>数据容器根据特点的不同，如：</p>
<ul>
<li>是否支持重复元素</li>
<li>是否可以修改</li>
<li>是否有序，等</li>
</ul>
<p>分为5类，分别是：列表（list）、元组（tuple）、字符串（str）、集合（set）、字典（dict）</p>
<h1 id="数据容器：list（列表）"><a href="#数据容器：list（列表）" class="headerlink" title="数据容器：list（列表）"></a>数据容器：list（列表）</h1><h2 id="列表的定义"><a href="#列表的定义" class="headerlink" title="列表的定义"></a>列表的定义</h2><p>基本语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字面量</span></span><br><span class="line">[元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,……]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">变量名称 = [元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,……]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义空列表</span></span><br><span class="line">变量名称 = []</span><br><span class="line">变量名称 = <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure>



<p>注意：</p>
<ul>
<li><p>列表的每一个元素，称之为元素</p>
</li>
<li><p>以 [] 作为标识</p>
</li>
<li><p>列表内每个元素之间用逗号隔开</p>
</li>
<li><p>列表可以一次存储多个数据，且可以为不同的数据类型，支持嵌套</p>
</li>
</ul>
<h2 id="列表的下标索引"><a href="#列表的下标索引" class="headerlink" title="列表的下标索引"></a>列表的下标索引</h2><p>列表的每个元素都有其位置下标索引，从前向后的方向，从0开始，依次递增，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法：列表[下标索引]</span></span><br><span class="line"></span><br><span class="line">name_list = [<span class="string">&#x27;Sam&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;Mark&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list[<span class="number">0</span>])		<span class="comment">#结果：Sam</span></span><br><span class="line"><span class="built_in">print</span>(name_list[<span class="number">1</span>])		<span class="comment">#结果：Jack</span></span><br><span class="line"><span class="built_in">print</span>(name_list[<span class="number">2</span>])		<span class="comment">#结果：Mark</span></span><br></pre></td></tr></table></figure>



<p>反向索引，从后往前的方向，从-1开始递减，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法：列表[下标索引]</span></span><br><span class="line"></span><br><span class="line">name_list = [<span class="string">&#x27;Sam&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;Mark&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list[-<span class="number">1</span>])		<span class="comment">#结果：Mark</span></span><br><span class="line"><span class="built_in">print</span>(name_list[-<span class="number">2</span>])		<span class="comment">#结果：Jack</span></span><br><span class="line"><span class="built_in">print</span>(name_list[-<span class="number">3</span>])		<span class="comment">#结果：Sam</span></span><br></pre></td></tr></table></figure>



<p>嵌套列表的下标索引，同上，写两层即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法 列表[下标][下标]</span></span><br></pre></td></tr></table></figure>



<h2 id="列表的常用操作"><a href="#列表的常用操作" class="headerlink" title="列表的常用操作"></a>列表的常用操作</h2><p>方法：在Python中，如果将函数定义为class（类）的成员，那么函数会称之为方法<strong>（写在类里的函数成为方法）</strong>，使用“.”访问</p>
<h3 id="列表的查询功能——index"><a href="#列表的查询功能——index" class="headerlink" title="列表的查询功能——index()"></a>列表的查询功能——index()</h3><ul>
<li><p>查询某元素下标</p>
<p>功能：查找指定元素在列表的下标，如果找不到，报错ValueError</p>
<p>语法：<strong>列表.index(元素)</strong></p>
</li>
</ul>
<h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><ul>
<li><p>修改特定位置（索引）的元素值</p>
<p>语法：<strong>列表[下标] &#x3D; 值</strong></p>
<p>通过如上语法即可直接对指定位置的值进行重新赋值</p>
</li>
<li><p>插入元素</p>
<p>语法：<strong>列表.insert(下标,元素)</strong></p>
<p>在指定的下标位置，插入指定元素，该位置原来的元素和后续元素，依次向后移</p>
</li>
<li><p>追加元素1</p>
<p>语法：<strong>列表.append(元素)</strong></p>
<p>将元素追加到列表的尾部</p>
</li>
<li><p>追加元素2</p>
<p>语法：<strong>列表.extend(其他数据容器)</strong></p>
<p>将其他数据容器的内容取出，依次追加到列表尾部</p>
</li>
<li><p>删除元素</p>
<p>语法1：<strong>del 列表[下标]</strong></p>
<p>语法2：<strong>列表.pop(下标)</strong></p>
<p>语法3：<strong>列表.remove(元素)</strong></p>
<p>方法pop()不仅可以删除元素，还会返回被删除的元素，remove()是删除某元素在列表的第一个匹配项</p>
</li>
<li><p>清空列表</p>
<p>语法：<strong>列表.clear()</strong></p>
<p>清空列表内容</p>
</li>
<li><p>统计某元素在列表内的数量</p>
<p>语法：<strong>列表.count(元素)</strong></p>
</li>
<li><p>统计列表中有多少元素</p>
<p>语法：<strong>len(列表)</strong></p>
<p>可以得到一个int型的数字，表示列表内的元素数量</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">语法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">查询某元素下标</td>
<td align="center">列表.index(元素)</td>
<td align="center">查找指定元素在列表的下标，如果找不到，报错ValueError</td>
</tr>
<tr>
<td align="center">修改元素值</td>
<td align="center">列表[下标] &#x3D; 值</td>
<td align="center">直接对指定位置的值进行重新赋值</td>
</tr>
<tr>
<td align="center">插入元素</td>
<td align="center">列表.insert(下标,元素)</td>
<td align="center">在指定的下标位置，插入指定元素，该位置原来的元素和后续元素，依次向后移</td>
</tr>
<tr>
<td align="center">追加元素</td>
<td align="center">列表.append(元素)</td>
<td align="center">将元素追加到列表的尾部</td>
</tr>
<tr>
<td align="center">追加元素</td>
<td align="center">列表.extend(其他数据容器)</td>
<td align="center">将其他数据容器的内容取出，依次追加到列表尾部</td>
</tr>
<tr>
<td align="center">删除元素</td>
<td align="center">del 列表[下标]</td>
<td align="center">删除下标位置上的元素</td>
</tr>
<tr>
<td align="center">删除元素</td>
<td align="center">列表.pop(下标)</td>
<td align="center">方法pop()不仅可以删除元素，还会返回被删除的元素</td>
</tr>
<tr>
<td align="center">删除元素</td>
<td align="center">列表.remove(元素)</td>
<td align="center">remove()是删除某元素在列表的第一个匹配项</td>
</tr>
<tr>
<td align="center">清空列表</td>
<td align="center">列表.clear()</td>
<td align="center">清空列表内容</td>
</tr>
<tr>
<td align="center">统计某元素数量</td>
<td align="center">列表.count(元素)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">统计列表元素</td>
<td align="center">len(列表)</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法：列表[下标索引]</span></span><br><span class="line"></span><br><span class="line">name_list = [<span class="string">&#x27;Sam&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;Mark&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list[<span class="number">0</span>])		<span class="comment">#结果：Sam</span></span><br><span class="line"><span class="built_in">print</span>(name_list[<span class="number">1</span>])		<span class="comment">#结果：Jack</span></span><br><span class="line"><span class="built_in">print</span>(name_list[<span class="number">2</span>])		<span class="comment">#结果：Mark</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法：列表[下标索引]</span></span><br><span class="line"></span><br><span class="line">name_list = [<span class="string">&#x27;Sam&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;Mark&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list[-<span class="number">1</span>])		<span class="comment">#结果：Mark</span></span><br><span class="line"><span class="built_in">print</span>(name_list[-<span class="number">2</span>])		<span class="comment">#结果：Jack</span></span><br><span class="line"><span class="built_in">print</span>(name_list[-<span class="number">3</span>])		<span class="comment">#结果：Sam</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.索引元素 index()</span></span><br><span class="line">index = name_list.index(<span class="string">&quot;Jack&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;“Jack”在列表中的位置是<span class="subst">&#123;index&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.修改元素</span></span><br><span class="line">name_list[<span class="number">2</span>] = <span class="string">&quot;Tom&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表修改元素后，结果是：\t\t<span class="subst">&#123;name_list&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.插入元素 insert()</span></span><br><span class="line">name_list.insert(<span class="number">2</span>,<span class="string">&quot;Mark&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表插入元素后，结果是：\t\t<span class="subst">&#123;name_list&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.追加元素 append()</span></span><br><span class="line">name_list.append(<span class="string">&quot;Peter&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表追加元素后，结果是：\t\t<span class="subst">&#123;name_list&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.追加元素 extend()</span></span><br><span class="line">name_list2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">name_list.extend(name_list2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表追加一个新列表后，结果是：\t<span class="subst">&#123;name_list&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.删除元素</span></span><br><span class="line"><span class="keyword">del</span> name_list[<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表删除元素后，结果是：\t\t<span class="subst">&#123;name_list&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">getWord = name_list.pop(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表取出元素后，结果是：\t\t<span class="subst">&#123;name_list&#125;</span>,取出的元素是：<span class="subst">&#123;getWord&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">name_list.remove(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表删除元素后，结果是：\t\t<span class="subst">&#123;name_list&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.清空列表</span></span><br><span class="line">name_list.clear()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;清空列表后，结果是：\t\t\t<span class="subst">&#123;name_list&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.统计列表内某元素的数量</span></span><br><span class="line">name_list = [<span class="string">&#x27;Sam&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;Mark&#x27;</span>,<span class="string">&#x27;Sam&#x27;</span>,<span class="string">&#x27;Sam&#x27;</span>,<span class="string">&#x27;Sam&#x27;</span>]</span><br><span class="line">count = name_list.count(<span class="string">&quot;Sam&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表中Sam的数量是：\t\t\t<span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.统计列表中有多少元素</span></span><br><span class="line">count = <span class="built_in">len</span>(name_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表中元素的数量是：\t\t\t<span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Sam</span></span><br><span class="line"><span class="string">Jack</span></span><br><span class="line"><span class="string">Mark</span></span><br><span class="line"><span class="string">Mark</span></span><br><span class="line"><span class="string">Jack</span></span><br><span class="line"><span class="string">Sam</span></span><br><span class="line"><span class="string">“Jack”在列表中的位置是1</span></span><br><span class="line"><span class="string">列表修改元素后，结果是：		[&#x27;Sam&#x27;, &#x27;Jack&#x27;, &#x27;Tom&#x27;]</span></span><br><span class="line"><span class="string">列表插入元素后，结果是：		[&#x27;Sam&#x27;, &#x27;Jack&#x27;, &#x27;Mark&#x27;, &#x27;Tom&#x27;]</span></span><br><span class="line"><span class="string">列表追加元素后，结果是：		[&#x27;Sam&#x27;, &#x27;Jack&#x27;, &#x27;Mark&#x27;, &#x27;Tom&#x27;, &#x27;Peter&#x27;]</span></span><br><span class="line"><span class="string">列表追加一个新列表后，结果是：	  [&#x27;Sam&#x27;, &#x27;Jack&#x27;, &#x27;Mark&#x27;, &#x27;Tom&#x27;, &#x27;Peter&#x27;, 1, 2, 3]</span></span><br><span class="line"><span class="string">列表删除元素后，结果是：		[&#x27;Sam&#x27;, &#x27;Jack&#x27;, &#x27;Mark&#x27;, &#x27;Tom&#x27;, &#x27;Peter&#x27;, 2, 3]</span></span><br><span class="line"><span class="string">列表取出元素后，结果是：		[&#x27;Sam&#x27;, &#x27;Jack&#x27;, &#x27;Mark&#x27;, &#x27;Tom&#x27;, &#x27;Peter&#x27;, 3],取出的元素是：2</span></span><br><span class="line"><span class="string">列表删除元素后，结果是：		[&#x27;Sam&#x27;, &#x27;Jack&#x27;, &#x27;Mark&#x27;, &#x27;Tom&#x27;, &#x27;Peter&#x27;]</span></span><br><span class="line"><span class="string">清空列表后，结果是：			 []</span></span><br><span class="line"><span class="string">列表中Sam的数量是：			  4</span></span><br><span class="line"><span class="string">列表中元素的数量是：			 6</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>可以容纳多个元素</li>
<li>可以容纳不同类型的元素</li>
<li>数据是有序储存（有下标序号）</li>
<li>允许重复数据存在</li>
<li>可以修改（增加或删除元素等）</li>
</ul>
<h2 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h2><ol>
<li>遍历：将容器的内容依次取出，并处理，称之为遍历</li>
<li>for和while对比<ul>
<li>for循环更简洁，while更灵活</li>
<li>for用于从容器内依次取出元素并处理，while可以用以任何需要循环的场景</li>
</ul>
</li>
</ol>
<h1 id="数据容器：tuple（元组）"><a href="#数据容器：tuple（元组）" class="headerlink" title="数据容器：tuple（元组）"></a>数据容器：tuple（元组）</h1><h2 id="元组的定义"><a href="#元组的定义" class="headerlink" title="元组的定义"></a>元组的定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字面量</span></span><br><span class="line">(元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,……)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">变量名称 = (元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,……)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义空列表</span></span><br><span class="line">变量名称 = ()</span><br><span class="line">变量名称 = <span class="built_in">tuple</span>()</span><br></pre></td></tr></table></figure>



<p>注意：</p>
<ul>
<li>元组只有一个数据时，这个数后面要添加<strong>逗号</strong></li>
<li>元组也支持嵌套</li>
<li>元组的下标索引与列表相同</li>
<li>元组的内容时不可修改的，否则会报错，但如果在元组中嵌套列表，嵌套的列表是可以修改的</li>
<li>多数特性和list一样，不同点在于不可修改</li>
</ul>
<h2 id="元组的相关操作"><a href="#元组的相关操作" class="headerlink" title="元组的相关操作"></a>元组的相关操作</h2><table>
<thead>
<tr>
<th align="center">语法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">index()</td>
<td align="center">查找某个数据，如果数据存在返回对于的下标，否则报错</td>
</tr>
<tr>
<td align="center">count()</td>
<td align="center">统计某个数据在当前元组出现的次数</td>
</tr>
<tr>
<td align="center">len(元组)</td>
<td align="center">统计元组内的元素个数</td>
</tr>
</tbody></table>
<h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义元组</span></span><br><span class="line">tup = (<span class="string">&quot;Sam&quot;</span>,<span class="string">&quot;Jack&quot;</span>,<span class="string">&quot;Mark&quot;</span>,<span class="string">&quot;Sam&quot;</span>,[<span class="string">&quot;唱歌&quot;</span>,<span class="string">&quot;篮球&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计元组长度</span></span><br><span class="line">num = <span class="built_in">len</span>(tup)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;元组的长度是：\t<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计元组中，&quot;Sam&quot;出现的次数</span></span><br><span class="line">num = tup.count(<span class="string">&quot;Sam&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;”Sam“出现的次数：\t<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引&quot;Mark&quot;在元组中的位置</span></span><br><span class="line">num = tup.index(<span class="string">&quot;Mark&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;”Mark“所在的位置：<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;原元组的元素：\t<span class="subst">&#123;tup&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除元组中嵌套的列表元素</span></span><br><span class="line">tup[<span class="number">4</span>].pop(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;删除元素后的元组：\t<span class="subst">&#123;tup&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在元组嵌套的列表中添加元素</span></span><br><span class="line">tup[<span class="number">4</span>].append(<span class="string">&quot;coding&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;添加元素后的元组：\t<span class="subst">&#123;tup&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">元组的长度是：		 5</span></span><br><span class="line"><span class="string">”Sam“出现的次数：	  2</span></span><br><span class="line"><span class="string">”Mark“所在的位置：  2</span></span><br><span class="line"><span class="string">原元组的元素：	     (&#x27;Sam&#x27;, &#x27;Jack&#x27;, &#x27;Mark&#x27;, &#x27;Sam&#x27;, [&#x27;唱歌&#x27;, &#x27;篮球&#x27;])</span></span><br><span class="line"><span class="string">删除元素后的元组：	(&#x27;Sam&#x27;, &#x27;Jack&#x27;, &#x27;Mark&#x27;, &#x27;Sam&#x27;, [&#x27;篮球&#x27;])</span></span><br><span class="line"><span class="string">添加元素后的元组：	(&#x27;Sam&#x27;, &#x27;Jack&#x27;, &#x27;Mark&#x27;, &#x27;Sam&#x27;, [&#x27;篮球&#x27;, &#x27;coding&#x27;])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="数据容器：str（字符串）"><a href="#数据容器：str（字符串）" class="headerlink" title="数据容器：str（字符串）"></a>数据容器：str（字符串）</h1><h2 id="字符串介绍"><a href="#字符串介绍" class="headerlink" title="字符串介绍"></a>字符串介绍</h2><ul>
<li>字符串是字符的容器</li>
<li>一个字符串可以存放任意数量的字符</li>
<li>支持下标索引</li>
<li>允许重复字符串存在</li>
<li>不可以修改</li>
<li>字符串定义和格式化在<a href="./Python%E5%9F%BA%E7%A1%80(%E4%B8%80)%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">Python基础（一）</a>中有介绍</li>
</ul>
<h2 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h2><table>
<thead>
<tr>
<th align="center">语法</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符串[下标]</td>
<td align="center">同列表、元组</td>
</tr>
<tr>
<td align="center">字符串.index()</td>
<td align="center">同列表、元组</td>
</tr>
<tr>
<td align="center">字符串.replace(字符串1,字符串2)</td>
<td align="center">将字符串1内容替换为字符串2的内容</td>
</tr>
<tr>
<td align="center">字符串.split(分隔符字符串)</td>
<td align="center">按照指定的分隔符字符串，将字符串划分为多个字符串，并存入列表对象中</td>
</tr>
<tr>
<td align="center">字符串.strip()</td>
<td align="center">去掉前后空格</td>
</tr>
<tr>
<td align="center">字符串.strip(字符串)</td>
<td align="center">去掉前后指定的字符串</td>
</tr>
<tr>
<td align="center">字符串.count(字符串)</td>
<td align="center">统计某个数据在当前元组出现的次数</td>
</tr>
<tr>
<td align="center">len(字符串)</td>
<td align="center">统计元组内的元素个数</td>
</tr>
</tbody></table>
<h1 id="数据容器（序列）的切片"><a href="#数据容器（序列）的切片" class="headerlink" title="数据容器（序列）的切片"></a>数据容器（序列）的切片</h1><p><strong>序列：</strong>内容连续、有序，可使用下标索引的一类数据容器，列表、元组、字符串均可以视为序列</p>
<p><strong>切片：</strong>从一个序列中，取出一个子序列</p>
<p>语法：序列[起始下标:结束下标:步长]</p>
<ul>
<li>起始下标：从何处开始，可以留空，留空视作从头开始</li>
<li>结束下标：何处结束（不含），可以留空，留空视作截到结尾</li>
<li>步长：依次取元素的间隔<ul>
<li>不写默认是1</li>
<li>步长1表示，一个个取元素，步长N表示每次跳过N-1个元素取</li>
<li>步长为负数表示反向取（起始下标和结束下标也要反向标记）</li>
</ul>
</li>
</ul>
<p>注意：切片操作不会影响序列本身，而是得到一个新的序列</p>
<h1 id="数据容器：set（集合）"><a href="#数据容器：set（集合）" class="headerlink" title="数据容器：set（集合）"></a>数据容器：set（集合）</h1><h2 id="集合的定义"><a href="#集合的定义" class="headerlink" title="集合的定义"></a>集合的定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义集合字面量</span></span><br><span class="line">&#123;元素,元素,……,元素&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义集合变量</span></span><br><span class="line">变量名称 = &#123;元素,元素,……,元素&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义空集合</span></span><br><span class="line">变量名称 = <span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>



<h2 id="集合的常用操作"><a href="#集合的常用操作" class="headerlink" title="集合的常用操作"></a>集合的常用操作</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">集合.add(元素)</td>
<td align="center">集合内添加一个元素</td>
</tr>
<tr>
<td align="center">集合.remove(元素)</td>
<td align="center">移除集合内指定的元素</td>
</tr>
<tr>
<td align="center">集合.pop()</td>
<td align="center">从集合中随机取出一个元素</td>
</tr>
<tr>
<td align="center">集合.clear()</td>
<td align="center">将集合清空</td>
</tr>
<tr>
<td align="center">集合1.difference(集合2)</td>
<td align="center">得到一个新集合，内含2个集合的差集，原有的2个集合内容不变</td>
</tr>
<tr>
<td align="center">集合1.difference_uodate(集合2)</td>
<td align="center">在集合1中，删除集合2中存在的元素集合1被修改，集合2不变</td>
</tr>
<tr>
<td align="center">集合1.union(集合2)</td>
<td align="center">得到1个新集合，内含2个集合的全部元素，原有的2个集合内容不变</td>
</tr>
<tr>
<td align="center">len(集合)</td>
<td align="center">得到一个整数。记录了集合的元素个数</td>
</tr>
</tbody></table>
<h2 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h2><ul>
<li>可以容纳多个元素</li>
<li>可以容纳不同类型的数据（混装）</li>
<li>数据时无序存储的（不支持下标索引）</li>
<li>不允许重复数据存在</li>
<li>可以修改</li>
<li>支持for循环遍历，不可以使用while循环遍历（无法下标索引）</li>
</ul>
<h1 id="数据容器：dict（字典）"><a href="#数据容器：dict（字典）" class="headerlink" title="数据容器：dict（字典）"></a>数据容器：dict（字典）</h1><h2 id="字典的定义"><a href="#字典的定义" class="headerlink" title="字典的定义"></a>字典的定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义字典字面量</span></span><br><span class="line">&#123;key:value , key:value , key:value ,……, key:value&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义字典变量</span></span><br><span class="line">my_dict = &#123;key:value , key:value , key:value ,……, key:value&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义空字典</span></span><br><span class="line">my_dict = &#123;&#125;</span><br><span class="line">my_dict = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure>



<h2 id="字典的常用操作"><a href="#字典的常用操作" class="headerlink" title="字典的常用操作"></a>字典的常用操作</h2><table>
<thead>
<tr>
<th align="center">语法</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字典[Key]</td>
<td align="center">获取指定Key对应的Value值</td>
</tr>
<tr>
<td align="center">字典[Key] &#x3D; Value</td>
<td align="center">添加或更新键值对</td>
</tr>
<tr>
<td align="center">字典.pop(Key)</td>
<td align="center">取出Key对应的Value并在字典内删除此Key的键值对</td>
</tr>
<tr>
<td align="center">字典.clear()</td>
<td align="center">请空字典</td>
</tr>
<tr>
<td align="center">字典.keys()</td>
<td align="center">获取字典的全部Key，可用for循环遍历字典</td>
</tr>
<tr>
<td align="center">len(字典)</td>
<td align="center">计算字典内的元素个数</td>
</tr>
</tbody></table>
<h2 id="字典的特点"><a href="#字典的特点" class="headerlink" title="字典的特点"></a>字典的特点</h2><ul>
<li>字典可以提供基于Key检索Value的场景实现，Key不可以重复（重复会覆盖）</li>
<li>键值对的Key和Value可以是任意类型数据（Key不可以是字典）</li>
<li>字典不可以下标索引，而是通过Key检索Value</li>
<li>每一份数据都是KeyValue键值对</li>
<li>支持for循环，不支持while循环</li>
<li>可以修改</li>
</ul>
<h1 id="数据容器的总结对比"><a href="#数据容器的总结对比" class="headerlink" title="数据容器的总结对比"></a>数据容器的总结对比</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">列表</th>
<th align="center">元素</th>
<th align="center">字符串</th>
<th align="center">集合</th>
<th align="center">字典</th>
</tr>
</thead>
<tbody><tr>
<td align="center">元素数量</td>
<td align="center">支持多个</td>
<td align="center">支持多个</td>
<td align="center">支持多个</td>
<td align="center">支持多个</td>
<td align="center">支持多个</td>
</tr>
<tr>
<td align="center">元素类型</td>
<td align="center">任意</td>
<td align="center">任意</td>
<td align="center">仅字符</td>
<td align="center">任意</td>
<td align="center">Key：除字典外任意类型，Value：任意类型</td>
</tr>
<tr>
<td align="center">下标索引</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">重复元素</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">可修改性</td>
<td align="center">支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">数据有序</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">可修改，可重复的一批数据记录场景</td>
<td align="center">不可修改，可重复的一批数据记录场景</td>
<td align="center">一串字符的记录场景</td>
<td align="center">不可重复的数据记录场景</td>
<td align="center">以Key检索Value的数据记录场景</td>
</tr>
</tbody></table>
<h1 id="数据容器的通用操作"><a href="#数据容器的通用操作" class="headerlink" title="数据容器的通用操作"></a>数据容器的通用操作</h1><table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通过for循环</td>
<td align="center">遍历容器（字典是遍历Key）</td>
</tr>
<tr>
<td align="center">max()</td>
<td align="center">容器内最大元素</td>
</tr>
<tr>
<td align="center">min()</td>
<td align="center">容器内最小元素</td>
</tr>
<tr>
<td align="center">len()</td>
<td align="center">容器元素个数</td>
</tr>
<tr>
<td align="center">list()</td>
<td align="center">转换为列表</td>
</tr>
<tr>
<td align="center">tuple()</td>
<td align="center">转换为元组</td>
</tr>
<tr>
<td align="center">str()</td>
<td align="center">转换为字符串</td>
</tr>
<tr>
<td align="center">set()</td>
<td align="center">转换为集合</td>
</tr>
<tr>
<td align="center">sorted(序列,[reverse&#x3D;True])</td>
<td align="center">排序，reverse&#x3D;True表示降序得到一个排好序的列表</td>
</tr>
</tbody></table>
<h1 id="字符串大小比较方式"><a href="#字符串大小比较方式" class="headerlink" title="字符串大小比较方式"></a>字符串大小比较方式</h1><p>字符串比较：从头到尾，一位位比较，其中一位大，后面就无需比较了</p>
<p>单个字符比较：通过ASCII码表，确定字符对应的码值数字来确定大小</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/04/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
</search>
